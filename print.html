<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Azure Scrolls</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Azure related posts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="About.html">About</a></li><li class="chapter-item "><a href="apim/integration-overview.html"><strong aria-hidden="true">1.</strong> Tutorials - Integrate App Gateway, APIM and Self-Hosted Gateway</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="apim/integration-prepare-environment.html"><strong aria-hidden="true">1.1.</strong> Prepare the VNET environment</a></li><li class="chapter-item "><a href="apim/integration-apim-vnet-internal.html"><strong aria-hidden="true">1.2.</strong> Connect APIM to internal VNET</a></li><li class="chapter-item "><a href="apim/integration-appgw-apim.html"><strong aria-hidden="true">1.3.</strong> Integrate APIM with AppGW</a></li><li class="chapter-item "><a href="apim/integration-deploy-shgw.html"><strong aria-hidden="true">1.4.</strong> Deploy self-hosted gateway</a></li><li class="chapter-item "><a href="apim/integration-appgw-shgw.html"><strong aria-hidden="true">1.5.</strong> Integrate AppGW with self-hosted gateway</a></li><li class="chapter-item "><a href="apim/integration-verification.html"><strong aria-hidden="true">1.6.</strong> Verify the deployment</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Azure Scrolls</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/chunliu/my-docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about" id="about">About</a></h1>
<p>Here are some articles and posts that I wrote but don't know where to park. They are all about Azure.</p>
<p>The site is built with <a href="https://github.com/rust-lang/mdBook">mdbook</a>.</p>
<p>Let me know your feedback, suggestions or issues: <a href="https://github.com/chunliu/my-docs/issues">issues on GitHub</a></p>
<h1><a class="header" href="#tutorials---integrate-application-gateway-api-management-and-self-hosted-gateway-in-internal-virtual-network" id="tutorials---integrate-application-gateway-api-management-and-self-hosted-gateway-in-internal-virtual-network">Tutorials - Integrate Application Gateway, API Management and Self-Hosted Gateway in internal virtual network</a></h1>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>An API Management (APIM) instance can be deployed in a virtual network (VNET) in Internal mode and then integrated with an Azure Application Gateway (AppGW) to provide access to both internal and external users. We can expand the APIM instance further with a self-hosted gateway to extend the capacity and the redundancy of the APIM.</p>
<p>In this series of tutorials, we discuss how to integrate an AppGW with an APIM instance and a self-hosted gateway in an virtual network in internal mode. You will learn the detailed process and steps, as well as things and issues you may need to pay attention.</p>
<p>The following diagram shows the components we will deploy in the tutorials. It is not meant to be a reference architecture of APIM, but just to show you what the deployment would look like. As the purpose of the tutorials is to show the possibility and how-to for such a deployment, we start the deployment from scratch and do it step by step.</p>
<p><img src="apim/images/apim-environment.png" alt="apim environment" /></p>
<p>The deployment can be automated with ARM template or Azure PowerShell module. We use Azure Portal in the tutorials to better illustrate the process and the steps. To keep our focus on the integration of APIM and to make it easier for illustration, we only use the built-in Echo API for testing. There is no additional backend API.</p>
<h1><a class="header" href="#prepare-the-virtual-network-environment" id="prepare-the-virtual-network-environment">Prepare the virtual network environment</a></h1>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Create a virtual network with 3 subnets</li>
<li>‚úÖ Create a private DNS zone and link it to the virtual network</li>
<li>‚úÖ Create an API Management instance</li>
</ul>
<h2><a class="header" href="#create-the-virtual-network" id="create-the-virtual-network">Create the virtual network</a></h2>
<p>As the first step, we create a virtual network with 3 subnets.</p>
<ol>
<li>Open <strong>Azure Portal</strong>, click <strong>Resource Groups</strong>.</li>
<li>Click <strong>Add</strong> to add a new resource group.</li>
<li>Give the resource group a name, e.g. <code>apim-rg</code>, and choose a region such as <strong>East US</strong>. Click <strong>Review + create</strong> button, and then click <strong>Create</strong>.</li>
<li>When the resource group is create, click <strong>Go to resource group</strong> to open it.</li>
<li>On the resource group page, click <strong>Add</strong> to add a new resource.</li>
<li>In the search box, input <code>Virtual Network</code>, click it from the dropdown and click <strong>Create</strong>.</li>
<li>Give the virtual network a name, e.g. <code>apim-vnet</code>, and choose the same region of the resource group. Click <strong>Next: IP Addresses</strong>.</li>
<li>Input CIDR for <strong>IPv4 address space</strong>, such as <code>172.17.0.0/16</code>, and add the following 3 subnets.</li>
</ol>
<table><thead><tr><th>Subnet name</th><th>Subnet address range</th></tr></thead><tbody>
<tr><td>apim-subnet</td><td>172.17.0.0/24</td></tr>
<tr><td>appgw-subnet</td><td>172.17.1.0/24</td></tr>
<tr><td>aks-subnet</td><td>172.17.2.0/24</td></tr>
</tbody></table>
<ol start="9">
<li>Click <strong>Review + create</strong> and then click <strong>Create</strong> to create the virtual network.</li>
</ol>
<h2><a class="header" href="#configure-the-private-dns-zone" id="configure-the-private-dns-zone">Configure the Private DNS Zone</a></h2>
<p>When you deploy API Management in a virtual network in Internal mode, all its service endpoints are only visible within the virtual network. The default domain name of API Management, <code>azure-api.net</code>, which is managed by Azure, cannot be used to access the service endpoints anymore. As API Management service only responds to requests to the host name configured on its service endpoints and it does not listen to requests coming from IP addresses, you need to configure custom domain names for the endpoints, and therefore need a DNS service in the virtual network to manage the custom domain names.</p>
<p>In the tutorials, we use a Private DNS Zone to manage the custom domain names.</p>
<ol>
<li>In Azure Portal, go to the <strong>apim-rg</strong> resource group. Click <strong>Add</strong> to add a new resource.</li>
<li>In the search box, input <code>Private DNS Zone</code>, click it on the dropdown and click <strong>Create</strong>.</li>
<li>Make sure <strong>apim-rg</strong> is selected as the resource group.</li>
<li>Input a top level domain name for <strong>Name</strong>. For example, we use <code>contoso.net</code> for it in the tutorials.</li>
<li>Click <strong>Review + create</strong> and then click <strong>Create</strong> to create the zone.</li>
<li>When the zone is created, click <strong>Go to resource</strong> to open it.</li>
<li>Click <strong>Virtual network links</strong> and then click <strong>Add</strong> to link it to the virtual network.
<img src="apim/images/private-dns-zone.png" alt="private DNS zone" /></li>
<li>Give the link a name, e.g. <code>apim-vnet-link</code>, choose <code>apim-vnet</code> and check <strong>Enable auto registration</strong>. Click <strong>OK</strong>.</li>
</ol>
<h2><a class="header" href="#create-the-api-management-instance" id="create-the-api-management-instance">Create the API Management instance</a></h2>
<p>In the <strong>apim-rg</strong> resource group, create an API Management instance. For more details, please see <a href="https://docs.microsoft.com/azure/api-management/get-started-create-service-instance">Create a new Azure API Management service instance</a>.</p>
<p>Please make sure you choose <strong>East US</strong> for the region which is the same as the virtual network, and choose either <code>Developer</code> or <code>Premium</code> for the <strong>Pricing tier</strong>. Only these two tiers support the virtual network integration.</p>
<p>When the APIM instance is created, all steps in this tutorial are completed. Let's move to the next one.</p>
<h1><a class="header" href="#connect-api-management-to-virtual-network-in-internal-mode" id="connect-api-management-to-virtual-network-in-internal-mode">Connect API Management to virtual network in Internal mode</a></h1>
<p>In the previous tutorial, you created the virtual network, the private DNS zone and the API Management instance. In this tutorial, we continue connecting the API Management instance to the virtual network in Internal mode.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Connect the APIM instance in the virtual network in Internal mode</li>
<li>‚úÖ Create custom domain names in the private DNS zone</li>
<li>‚úÖ Create self-signed certificates with PowerShell script</li>
<li>‚úÖ Configure the APIM instance with custom domain names</li>
</ul>
<h2><a class="header" href="#connect-apim-instance-to-the-vnet-in-internal-mode" id="connect-apim-instance-to-the-vnet-in-internal-mode">Connect APIM instance to the VNET in Internal mode</a></h2>
<ol>
<li>
<p>In Azure Portal, open the APIM instance you created in the previous tutorial.</p>
</li>
<li>
<p>Click <strong>Virtual network</strong> under <strong>Deployment and infrastructure</strong> to open the VNET integration page.</p>
</li>
<li>
<p>Choose <strong>Internal</strong> for <strong>Virtual network</strong> and click the VNET option below to choose the VNET and the subnet.</p>
</li>
<li>
<p>Choose <strong>apim-vnet</strong> for the virtual network and <strong>apim-subnet</strong> for the subnet. Click <strong>Apply</strong>.</p>
<p><img src="apim/images/apim-internal-vnet.png" alt="apim internal vnet" /></p>
</li>
<li>
<p>Click <strong>Save</strong> to apply the changes. The changes could take 15 to 45 minutes to be applied.</p>
</li>
<li>
<p>When the APIM instance is deployed in the VNET successfully, you can find the <strong>private</strong> and <strong>public</strong> virtual IP addresses for the APIM instance on the <strong>Overview</strong> page. Take a note for the private IP address. We need to use it later.</p>
<p><img src="apim/images/apim-private-ip.png" alt="private IP address" /></p>
</li>
</ol>
<p>For more information about the impact of the VNET Internal mode, please see <a href="https://docs.microsoft.com/azure/api-management/api-management-using-with-internal-vnet">this document</a>.</p>
<h2><a class="header" href="#create-custom-domain-names" id="create-custom-domain-names">Create custom domain names</a></h2>
<p>With VNET Internal mode, we need to configure the APIM instance with custom domain names before we can access its service endpoints. In our scenarios, we need at least 2 domain names, one for the <strong>Gateway</strong> endpoint and the other for the <strong>Management</strong> endpoint.</p>
<ol>
<li>In Azure Portal, open the private DNS zone <strong>contoso.net</strong>.</li>
<li>Click <strong>Record set</strong> to add a new record set.</li>
<li>Create the record set with <strong>Name</strong>: <code>apim-gw</code> and <strong>IP address</strong>: <code>172.17.0.5</code> which is the private IP address we get in previous steps.
<img src="apim/images/private-zone-recordset.png" alt="record set" /></li>
<li>Repeat the steps to create another record set with <strong>Name</strong>: <code>apim-mgmt</code> and <strong>IP address</strong>: <code>172.17.0.5</code>.</li>
</ol>
<h2><a class="header" href="#create-self-signed-certificates-for-ssl" id="create-self-signed-certificates-for-ssl">Create self-signed certificates for SSL</a></h2>
<p>We also need certificates for SSL bindings of APIM. In the production environment, you should use the certificates that are trusted by your organization. We use self-signed certificates in these tutorials just for demo purpose.</p>
<p>To make things easier, we create 2 certificates with the following PowerShell script. One of the certificates is a root certificate for signing, and the other is a wildcard certificate (CN=*.contoso.net) for SSL bindings of the custom domain names.</p>
<pre><code class="language-PowerShell"># Create the root signing cert
$root = New-SelfSignedCertificate -Type Custom -KeySpec Signature `
    -Subject &quot;CN=contoso-net-signing-root&quot; -KeyExportPolicy Exportable `
    -HashAlgorithm sha256 -KeyLength 4096 `
    -CertStoreLocation &quot;Cert:\CurrentUser\My&quot; -KeyUsageProperty Sign `
    -KeyUsage CertSign -NotAfter (get-date).AddYears(5)
# Create the wildcard SSL cert.
$ssl = New-SelfSignedCertificate -Type Custom -DnsName &quot;*.contoso.net&quot;,&quot;contoso.net&quot; `
    -KeySpec Signature `
    -Subject &quot;CN=*.contoso.net&quot; -KeyExportPolicy Exportable `
    -HashAlgorithm sha256 -KeyLength 2048 `
    -CertStoreLocation &quot;Cert:\CurrentUser\My&quot; `
    -Signer $root
# Export CER of the root and SSL certs
Export-Certificate -Type CERT -Cert $root -FilePath .\contoso-signing-root.cer
Export-Certificate -Type CERT -Cert $ssl -FilePath .\contoso-ssl.cer
# Export PFX of the root and SSL certs
Export-PfxCertificate -Cert $root -FilePath .\contoso-signing-root.pfx `
    -Password (read-host -AsSecureString -Prompt &quot;password&quot;)
Export-PfxCertificate -Cert $ssl -FilePath .\contoso-ssl.pfx `
    -ChainOption BuildChain -Password (read-host -AsSecureString -Prompt &quot;password&quot;)
</code></pre>
<p>With the above script, you get the following 4 files.</p>
<ul>
<li>contoso-signing-root.cer</li>
<li>contoso-signing-root.pfx</li>
<li>contoso-ssl.cer</li>
<li>contoso-ssl.pfx</li>
</ul>
<p>Please note down the passwords you use for the PFX files. We need to use them later.</p>
<h2><a class="header" href="#configure-custom-domain-names-for-the-apim-instance" id="configure-custom-domain-names-for-the-apim-instance">Configure custom domain names for the APIM instance</a></h2>
<p>In the production environment, Azure Key Vault is recommended to manage the certificates. We use the <strong>Custom</strong> option in this tutorial. For more information about configuring custom domain, please see <a href="https://docs.microsoft.com/azure/api-management/configure-custom-domain">this document</a>.</p>
<ol>
<li>
<p>In the Azure Portal, go to the APIM instance.</p>
</li>
<li>
<p>Click <strong>Custom domains</strong> and click <strong>Add</strong>.</p>
</li>
<li>
<p>Configure the custom domain for the <strong>Gateway</strong> and <strong>Management</strong> endpoints with the following values.</p>
<p><img src="apim/images/apim-custom-domain.png" alt="custom domain" /></p>
</li>
</ol>
<table><thead><tr><th>Type</th><th>Hostname</th><th>Certificate file</th><th>Password</th><th>Default SSL binding</th></tr></thead><tbody>
<tr><td>Gateway</td><td>apim-gw.contoso.net</td><td>contoso-ssl.pfx</td><td><em>password of contoso-ssl.pfx</em></td><td>True</td></tr>
<tr><td>Management</td><td>apim-mgmt.contoso.net</td><td>contoso-ssl.pfx</td><td><em>password of contoso-ssl.pfx</em></td><td>True</td></tr>
</tbody></table>
<ol start="4">
<li>Click <strong>Save</strong> to apply the changes.</li>
</ol>
<p>The APIM instance is connected to the VNET in the Internal mode. You can move on to the next tutorial.</p>
<h1><a class="header" href="#integrate-the-apim-instance-with-application-gateway" id="integrate-the-apim-instance-with-application-gateway">Integrate the APIM instance with Application Gateway</a></h1>
<p>In the last tutorial, you connected the APIM instance to the VNET in Internal mode and configured the custom domain names for it. In this tutorial, we continue integrating the APIM instance with an Application Gateway.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Create Application Gateway</li>
<li>‚úÖ Create the custom healthy probe for APIM</li>
<li>‚úÖ Verify the integration</li>
</ul>
<h2><a class="header" href="#create-application-gateway" id="create-application-gateway">Create Application Gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, add a new resource by clicking <strong>Create a resource</strong> link.</p>
</li>
<li>
<p>Search and create <code>Application Gateway</code>.</p>
</li>
<li>
<p>Choose resource group <code>apim-rg</code>, region <code>East US</code>, and give it a name such as <code>apim-appgw</code>.</p>
</li>
<li>
<p>Choose VNET <code>apim-vnet</code> and subnet <code>appgw-subnet</code>. Click <strong>Next: Frontends</strong> button.</p>
</li>
<li>
<p>Choose <code>Public</code> for the frontend IP and create a new public IP address. And then click <strong>Next: backend</strong> button.</p>
</li>
<li>
<p>Add a backend pool as shown in the following diagram.</p>
<p><img src="apim/images/appgw-backend-pool.png" alt="AppGW backend pool" /></p>
</li>
<li>
<p>Move to <strong>Configuration</strong> and add a routing rule. The <strong>Listener</strong> of the routing rule is shown below.</p>
<p><img src="apim/images/appgw-listener.png" alt="AppGW routing rule" /></p>
</li>
<li>
<p>Choose <strong>apim-backend</strong> as the <strong>Backend target</strong>, and add a new <strong>HTTP settings</strong> as shown below. Note that <code>contoso-signing-root.cer</code> is used for <strong>CER certificate</strong> and <strong>Host name override</strong> is set to pick the name from backend.</p>
<p><img src="apim/images/appgw-http-settings.png" alt="AppGW http settings" /></p>
</li>
<li>
<p>Move to <strong>Tags</strong> and add tags if you want. Then move to <strong>Review + create</strong>.</p>
</li>
<li>
<p>Click <strong>Create</strong> to create the AppGW.</p>
</li>
</ol>
<h2><a class="header" href="#create-custom-health-probe" id="create-custom-health-probe">Create custom health probe</a></h2>
<p>When the deployment of the AppGW is completed, if you go to the resource, you would notice that the backend status is unhealthy. That is because the default probe of AppGW doesn't work for APIM. We need to create a custom health probe for it.</p>
<p><img src="apim/images/appgw-default-probe.png" alt="AppGW default probe" /></p>
<ol>
<li>
<p>Click <strong>Health probes</strong> and click <strong>Add</strong> to add a custom health probe. The details of the custom health probe are shown in the diagram below. Note the <strong>Protocol</strong> and host name settings. The <strong>Path</strong> of the APIM probe is <code>/status-0123456789abcdef</code>.</p>
<p><img src="apim/images/appgw-custom-probe.png" alt="AppGW custom probe" /></p>
</li>
<li>
<p>Uncheck <strong>I want to test the backend health before adding the health probe</strong> option and click <strong>Add</strong>.</p>
</li>
<li>
<p>Go to <strong>Backend health</strong> and refresh. The status of the backend should be <strong>Healthy</strong> now.</p>
<p><img src="apim/images/appgw-custom-probe-healthy.png" alt="AppGW healthy probe" /></p>
</li>
</ol>
<h2><a class="header" href="#verify-the-integration" id="verify-the-integration">Verify the integration</a></h2>
<p>We can verify if the integration works by sending a request to the public IP address of the AppGW. We do it with <a href="https://docs.microsoft.com/azure/cloud-shell/overview">Azure Cloud Shell</a> in this tutorial. You can also do it with other tools such as Postman.</p>
<ol>
<li>
<p>In the Azure Portal, open Azure Cloud Shell. Choose <strong>Bash</strong> for the shell.</p>
</li>
<li>
<p>Run the following command with <code>curl</code>. You can find the <a href="https://docs.microsoft.com/azure/api-management/api-management-subscriptions">subscription</a> key of APIM on the <strong>Subscriptions</strong> page of APIM, and the public IP address of AppGW on the <strong>Overview</strong> page of AppGW.</p>
<pre><code class="language-bash">curl -I -H &quot;Ocp-Apim-Subscription-Key: [subscription key]&quot; http://[AppGW public IP]/echo/resource
</code></pre>
</li>
<li>
<p>If everything works, you get <code>HTTP 200 OK</code> in the response.</p>
</li>
</ol>
<p>Now you've integrated the APIM instance with an AppGW. Let's move on to the next tutorial to expand the deployment further with a self-hosted gateway.</p>
<h1><a class="header" href="#deploy-self-hosted-gateway" id="deploy-self-hosted-gateway">Deploy self-hosted gateway</a></h1>
<p>In the previous tutorials, you've deployed the APIM instance in the internal VNET and integrated it with the AppGW. In this tutorial, we expand the deployment with a <a href="https://docs.microsoft.com/azure/api-management/self-hosted-gateway-overview">self-hosted gateway</a> to extend the capacity and redundancy of the APIM instance.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Deploy an Azure Kubernetes Service (AKS) cluster in the VNET</li>
<li>‚úÖ Deploy a self-hosted gateway in the AKS cluster</li>
</ul>
<h2><a class="header" href="#deploy-an-aks-cluster-to-host-the-self-hosted-gateway" id="deploy-an-aks-cluster-to-host-the-self-hosted-gateway">Deploy an AKS cluster to host the self-hosted gateway</a></h2>
<p>The self-hosted gateway of APIM is a containerized, functionally-equivalent version of the managed gateway that is part of every APIM service deployed. It can be deployed to Docker, Kubernetes, or any other container orchestration solution running on a server cluster on premises, cloud infrastructure, or for evaluation and development purposes, on a personal computer. In this tutorial, we deploy an AKS cluster to host the self-hosted gateway.</p>
<h3><a class="header" href="#create-a-service-principal-and-assign-permissions" id="create-a-service-principal-and-assign-permissions">Create a service principal and assign permissions</a></h3>
<p>To allow the AKS cluster to access the VNET and subnet, we need to configure it with a <a href="https://docs.microsoft.com/azure/active-directory/develop/app-objects-and-service-principals#service-principal-object">service principal</a>.</p>
<ol>
<li>
<p>In the Azure Portal, open Cloud Shell and choose <strong>Bash</strong> as the shell.</p>
</li>
<li>
<p>Run the following command to create the service principal and take a note on the output. We need to use it later.</p>
<pre><code class="language-bash">az ad sp create-for-rbac --skip-assignment
</code></pre>
</li>
<li>
<p>Assign the service principal <strong>Network Contributor</strong> role to the VNET with the following command. <code>&lt;appId&gt;</code> is the value of <code>appId</code> from the output of the above step.</p>
<pre><code class="language-bash">VNET_ID=$(az network vnet show --resource-group apim-rg --name apim-vnet --query id -o tsv)
az role assignment create --assignee &lt;appId&gt; --scope $VNET_ID --role &quot;Network Contributor&quot;
</code></pre>
</li>
</ol>
<h3><a class="header" href="#deploy-the-aks-cluster-with-azure-portal" id="deploy-the-aks-cluster-with-azure-portal">Deploy the AKS cluster with Azure Portal</a></h3>
<p>We deploy the AKS cluster to the VNET and the corresponding subnet. For details about the AKS networking, please see <a href="https://docs.microsoft.com/azure/aks/configure-kubenet">this document</a>.</p>
<ol>
<li>
<p>In the Azure Portal, add a new resource to the <strong>apim-rg</strong> resource group.</p>
</li>
<li>
<p>Search <code>Kubernetes Service</code> and click <strong>Create</strong>.</p>
</li>
<li>
<p>Choose resource group <code>apim-rg</code>, region <code>East US</code> and give the cluster a name such as <code>apim-aks</code>. Accept other default settings and move to <strong>Next: Node pools</strong>.</p>
</li>
<li>
<p>Accept default settings for node pools and move to <strong>Next: Authentication</strong>.</p>
</li>
<li>
<p>Choose <strong>Service principal</strong> as the <strong>Authentication method</strong> and click <strong>Configure service principal</strong> to configure it.</p>
</li>
<li>
<p>Choose <strong>Use existing</strong>, and input the <strong>client ID</strong> and <strong>client secret</strong>. They are the values of <strong>appID</strong> and <strong>password</strong> from the output of creating the service principal command.</p>
<p><img src="apim/images/aks-service-principal.png" alt="aks service principal" /></p>
</li>
<li>
<p>Move to <strong>Next: Networking</strong>.</p>
</li>
<li>
<p>Choose <strong>Advanced</strong> for <strong>Network configuration</strong> option and apply the settings as shown in the diagram below.</p>
<p><img src="apim/images/aks-vnet.png" alt="aks vnet" /></p>
</li>
<li>
<p>Click <strong>Review + create</strong> and then click <strong>Create</strong> to deploy the AKS cluster.</p>
</li>
<li>
<p>When the deployment is completed, open Cloud Shell and run the following command. Make sure the cluster info of the AKS cluster can be shown.</p>
<pre><code class="language-bash">az aks get-credentials --resource-group apim-rg --name apim-aks
kubectl cluster-info
</code></pre>
</li>
</ol>
<h2><a class="header" href="#deploy-the-self-hosted-gateway" id="deploy-the-self-hosted-gateway">Deploy the self-hosted gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, go to the API Management.</p>
</li>
<li>
<p>Click <strong>Gateways</strong> and click <strong>Add</strong> to add a self-hosted gateway as shown below.</p>
<p><img src="apim/images/apim-add-shgw.png" alt="add self-hosted gateway" /></p>
</li>
<li>
<p>When the gateway is added, click it to open its settings.</p>
</li>
<li>
<p>Click <strong>Deployment</strong> and then click <strong>Kubernetes</strong>.</p>
</li>
</ol>
<p>In normal cases, we can use the yaml to deploy the gateway straightly. But as we are in an internal VNET environment, we need to make some changes to the yaml before it can be deployed.</p>
<ol start="5">
<li>
<p>Open the Cloud Shell. Copy and run the following command to create the secret for the gateway key in AKS first.</p>
<p><img src="apim/images/shgw-secret.png" alt="secret for shgw key" /></p>
</li>
</ol>
<p>As we are using custom domain names and self-signed SSL certificate, the certificate needs to be trusted by the self-hosted gateway. We create a configMap to install the certificate to the gateway pod.</p>
<blockquote>
<p>In production environment, you would want to use more secured options, such as Pod Identity and Azure Key Vault, to manage the certificates.</p>
</blockquote>
<ol start="6">
<li>
<p>In the Cloud Shell, upload <strong>contoso-signing-root.cer</strong>.</p>
<p><img src="apim/images/cloud-shell-upload.png" alt="cloud shell upload" /></p>
</li>
<li>
<p>Convert the CER to PEM before it can be used for the gateway pod.</p>
<pre><code class="language-bash">openssl x509 -inform der -in contoso-signing-root.cer -out contoso-signing-root.pem
</code></pre>
</li>
<li>
<p>Create a configMap in the AKS for the certificate.</p>
<pre><code class="language-bash">kubectl create configmap signing-root --from-file=contoso-signing-root.pem
</code></pre>
</li>
</ol>
<p>We need to make 3 changes to the yaml file generated by APIM.</p>
<ul>
<li>Change the <strong>config.service.endpoint</strong> to use the custom domain name of the management service endpoint.</li>
<li>Install the certificate to the pod so that it can be trusted by the pod.</li>
<li>Use an <a href="https://docs.microsoft.com/azure/aks/internal-lb">internal load balancer</a> to expose the gateway service.</li>
</ul>
<ol start="9">
<li>
<p>Open the editor of the Cloud Shell, and then copy and paste the content of the yaml generated by APIM to it.</p>
<p><img src="apim/images/cloud-shell-editor.png" alt="cloud shell editor" /></p>
</li>
<li>
<p>Change the domain name of <strong>config.service.endpoint</strong> to <code>apim-mgmt.contoso.net</code>.</p>
</li>
<li>
<p>Add the annotation for the internal load balancer, <code>service.beta.kubernetes.io/azure-load-balancer-internal: &quot;true&quot;</code>, to the service.</p>
</li>
<li>
<p>Create a volume based on the configMap <code>signing-root</code> and mount the <code>contoso-signing-root.pem</code> from it. The complete code of the yaml is shown below.</p>
<blockquote>
<p>Note that you need to change the <code>&lt;subscription id&gt;</code> in <strong>config.service.endpoint</strong>.</p>
</blockquote>
<pre><code class="language-yml"># NOTE: Before deploying into production please review documentation -&gt; https://aka.ms/self-hosted-gateway-production
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: apim-shgw-env
data: # change to the domain name of management endpoint
  config.service.endpoint: &quot;https://apim-mgmt.contoso.net/subscriptions/&lt;subscription id&gt;/resourceGroups/apim-rg/providers/Microsoft.ApiManagement/service/apiminst32?api-version=2019-12-01&quot;
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: apim-shgw
spec:
  replicas: 1
  selector:
    matchLabels:
      app: apim-shgw
  template:
    metadata:
      labels:
        app: apim-shgw
    spec:
      containers:
      - name: apim-shgw
        image: mcr.microsoft.com/azure-api-management/gateway:latest
        ports:
        - name: http
          containerPort: 8080
        - name: https
          containerPort: 8081
        env:
        - name: config.service.auth
          valueFrom:
            secretKeyRef:
              name: apim-shgw-token
              key: value
        envFrom:
        - configMapRef:
            name: apim-shgw-env
        volumeMounts: # mount the signing certificate
        - name: signing-root-volume
          mountPath: /etc/ssl/certs/contoso-signing-root.pem
          subPath: contoso-signing-root.pem
          readOnly: false
      volumes:
      - name: signing-root-volume
        configMap:
          name: signing-root
---
apiVersion: v1
kind: Service
metadata:
  name: apim-shgw
  annotations: # use internal load balancer
    service.beta.kubernetes.io/azure-load-balancer-internal: &quot;true&quot;
spec:
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: https
    port: 443
    targetPort: 8081
  selector:
    app: apim-shgw
</code></pre>
</li>
<li>
<p>Save the yaml to a file, <code>apim-shgw.yaml</code>, and run the following command to deploy it.</p>
<pre><code class="language-bash">kubectl apply -f ./apim-shgw.yaml
</code></pre>
</li>
<li>
<p>When the self-hosted gateway is deployed successfully, you would see 1 node in the status of the self-hosted gateway in the Azure Portal.</p>
<p><img src="apim/images/shgw-deploy-success.png" alt="gateway deployed successfully" /></p>
<blockquote>
<p>In case if the deployment is completed but the node in the status keeps showing 0, you can check the log of pod with <code>kubectl logs &lt;pod-name&gt;</code> to find out what is wrong. Possible reasons could be the URL of the management endpoint is incorrect or the root certificate is not installed properly.</p>
</blockquote>
</li>
</ol>
<p>In the next tutorial, we will integrate the self-hosted gateway with the Application Gateway.</p>
<h1><a class="header" href="#integrate-application-gateway-with-the-self-hosted-gateway" id="integrate-application-gateway-with-the-self-hosted-gateway">Integrate Application Gateway with the self-hosted gateway</a></h1>
<p>In the previous tutorial, you've deployed the self-hosted gateway in the AKS cluster. In this tutorial, you continue integrating it with the Application Gateway which is the last piece of the puzzle.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Configure the domain name for the self-hosted gateway</li>
<li>‚úÖ Integrate the AppGW with the self-hosted gateway</li>
</ul>
<h2><a class="header" href="#configure-the-domain-name-for-the-self-hosted-gateway" id="configure-the-domain-name-for-the-self-hosted-gateway">Configure the domain name for the self-hosted gateway</a></h2>
<p>Before the self-hosted gateway can be added to the backend pool of the AppGW, you need to configure a custom domain name for it.</p>
<ol>
<li>
<p>Open Cloud Shell and run the following command to find the IP address of the self-hosted gateway service.</p>
<pre><code class="language-bash">kubectl get service
</code></pre>
</li>
<li>
<p>Take a note of the <strong>External-IP</strong> address of <strong>apim-shgw</strong> service.</p>
<blockquote>
<p>The external IP of the service is within the address space of the VNET because we used an internal load balancer for it.</p>
</blockquote>
<p><img src="apim/images/shgw-service-ip.png" alt="service ip" /></p>
</li>
<li>
<p>In the Azure Portal, go to the private DNS zone <code>contoso.net</code>, add a new record set and point it to the IP address of the gateway service, as shown below.</p>
<p><img src="apim/images/shgw-record-set.png" alt="shgw record set" /></p>
</li>
<li>
<p>Go to API Management in the Azure Portal.</p>
</li>
<li>
<p>Click <strong>Certificates</strong> and click <strong>Add</strong> to add the SSL certificate.</p>
</li>
<li>
<p>Add <code>contoso-ssl.pfx</code>, as shown below.</p>
<p><img src="apim/images/apim-add-cert.png" alt="apim add cert" /></p>
</li>
<li>
<p>Open the self-hosted gateway settings by clicking <strong>Gateways</strong> and the gateway.</p>
</li>
<li>
<p>Click <strong>Hostnames</strong> and click <strong>Add</strong> to add a new host name for the gateway.</p>
<p><img src="apim/images/shgw-hostname.png" alt="shgw host name" /></p>
</li>
</ol>
<h2><a class="header" href="#integrate-appgw-with-the-self-hosted-gateway" id="integrate-appgw-with-the-self-hosted-gateway">Integrate AppGW with the self-hosted gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, go to Application Gateway.</p>
</li>
<li>
<p>Click <strong>Backend pools</strong> and the existing backend pool <strong>apim-backend</strong>.</p>
</li>
<li>
<p>Add <code>apim-shgw.contoso.net</code> as a new type of <strong>IP address or FQDN</strong> target.</p>
</li>
<li>
<p>When the backend target is added to the backend pool, click <strong>Health probes</strong> and the existing custom probe <strong>apim-probe</strong>.</p>
</li>
<li>
<p>Update the <strong>Path</strong> from <code>/status-0123456789abcdef</code> to <code>/internal-status-0123456789abcdef</code>. Uncheck <strong>I want to test the backend health before adding the health probe</strong> and click <strong>Save</strong> to save the changes.</p>
<blockquote>
<p>At the moment, the documented probe path of APIM, <code>/status-0123456789abcdef</code>, doesn't work for the self-hosted gateway. <code>/internal-status-0123456789abcdef</code> is an undocumented probe path which works for both APIM and the self-hosted gateway temporarily. The APIM product team is working on an update of the probe path for the self-hosted gateway. You need to update the path again when the update is available.</p>
</blockquote>
</li>
<li>
<p>Click <strong>Backend health</strong> to check the health of the backend. You should see both targets are healthy.</p>
<p><img src="apim/images/appgw-both-backend-healthy.png" alt="app gateway both backend targets are healthy" /></p>
</li>
</ol>
<p>At this point, you've completed all tasks and steps that are needed to integrate Application Gateway, API Management and Self-Hosted Gateway in and internal virtual network.</p>
<p>Move on to the last tutorial of this series, we will run a quick test to see how the whole environment works.</p>
<h1><a class="header" href="#verify-the-deployment" id="verify-the-deployment">Verify the deployment</a></h1>
<p>In the previous tutorials, you've deployed the following environment in Azure. In this tutorial, we test if the deployment works as expected, and if the requests can be load balanced and handled by both APIM and the self-hosted gateway.</p>
<p><img src="apim/images/apim-environment.png" alt="architecture" /></p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Send requests to API Management through Application Gateway</li>
<li>‚úÖ Verify if the requests are distributed to both API Managenet and the self-hosted gateway</li>
</ul>
<h2><a class="header" href="#send-requests-through-application-gateway" id="send-requests-through-application-gateway">Send requests through Application Gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, open Azure Cloud Shell. Choose <strong>Bash</strong> for the shell.</p>
</li>
<li>
<p>Run the following command with <code>curl</code>. You can find the <a href="https://docs.microsoft.com/azure/api-management/api-management-subscriptions">subscription</a> key of APIM on its <strong>Subscriptions</strong> page, and the public IP address of AppGW on its <strong>Overview</strong> page.</p>
<pre><code class="language-bash">curl -I -H &quot;Ocp-Apim-Subscription-Key: [subscription key]&quot; http://[AppGW public IP]/echo/resource
</code></pre>
</li>
<li>
<p>If everything works, you get <code>HTTP 200 OK</code> in the response.</p>
</li>
</ol>
<h2><a class="header" href="#test-if-the-requests-are-distributed-to-both-apim-and-the-self-hosted-gateway" id="test-if-the-requests-are-distributed-to-both-apim-and-the-self-hosted-gateway">Test if the requests are distributed to both APIM and the self-hosted gateway</a></h2>
<p>To test if the requests are handled by either APIM or the self-hosted gateway, you can send HTTP header <code>Ocp-Apim-Trace</code> to enable the trace of APIM. To make the verification even more intuitive, we use a custom policy to retrieve the host from APIM.</p>
<ol>
<li>
<p>In the Azure Portal, go to API Management.</p>
</li>
<li>
<p>Click <strong>APIs</strong> &gt; <strong>Echo API</strong> &gt; <strong>All operations</strong>.</p>
</li>
<li>
<p>Click <strong>&lt;/&gt;</strong> on the <strong>Inbound processing</strong> card to open the policy editor.</p>
</li>
<li>
<p>Replace the code in the policy editor with the code below.</p>
<pre><code class="language-xml">&lt;policies&gt;
    &lt;inbound&gt;
        &lt;base /&gt;
        &lt;set-variable name=&quot;inbound-host&quot; value=&quot;@(context.Request.Headers.GetValueOrDefault(&quot;Host&quot;))&quot; /&gt;
    &lt;/inbound&gt;
    &lt;backend&gt;
        &lt;base /&gt;
    &lt;/backend&gt;
    &lt;outbound&gt;
        &lt;base /&gt;
        &lt;set-header name=&quot;apim-host&quot; exists-action=&quot;override&quot;&gt;
            &lt;value&gt;@((string)context.Variables[&quot;inbound-host&quot;])&lt;/value&gt;
        &lt;/set-header&gt;
    &lt;/outbound&gt;
    &lt;on-error&gt;
        &lt;base /&gt;
    &lt;/on-error&gt;
&lt;/policies&gt;
</code></pre>
</li>
<li>
<p>In the Cloud Shell, run the same <code>curl</code> command as shown in the previous section. Run the command multiple times. You'll notice that the <code>apim-header</code> in the response could be either <code>apim-gw.contoso.net</code>, which is the APIM instance, or <code>apim-shgw.contoso.net</code>, which is the self-hosted gateway. AppGW uses the round robin to distribute the requests to both of them.</p>
<p><img src="apim/images/nlb-verification.png" alt="nlb verification" /></p>
</li>
</ol>
<p>You've completed this series of tutorials. Congratulations! üéâ</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
