<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Azure Scrolls</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Azure related posts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="About.html">About</a></li><li class="chapter-item "><a href="apim/integration-overview.html"><strong aria-hidden="true">1.</strong> Tutorials - Integrate App Gateway, APIM and Self-Hosted Gateway</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="apim/integration-prepare-environment.html"><strong aria-hidden="true">1.1.</strong> Prepare the VNET environment</a></li><li class="chapter-item "><a href="apim/integration-apim-vnet-internal.html"><strong aria-hidden="true">1.2.</strong> Connect APIM to internal VNET</a></li><li class="chapter-item "><a href="apim/integration-appgw-apim.html"><strong aria-hidden="true">1.3.</strong> Integrate APIM with AppGW</a></li><li class="chapter-item "><a href="apim/integration-deploy-shgw.html"><strong aria-hidden="true">1.4.</strong> Deploy self-hosted gateway</a></li><li class="chapter-item "><a href="apim/integration-appgw-shgw.html"><strong aria-hidden="true">1.5.</strong> Integrate AppGW with self-hosted gateway</a></li><li class="chapter-item "><a href="apim/integration-verification.html"><strong aria-hidden="true">1.6.</strong> Verify the deployment</a></li></ol></li><li class="chapter-item "><a href="appservice/spring-boot-mysql.html"><strong aria-hidden="true">2.</strong> Spring Boot, MySQL and Azure App Service</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Azure Scrolls</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/chunliu/my-docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about" id="about">About</a></h1>
<p>Here are some articles and posts that I wrote but don't know where to park. They are all about Azure.</p>
<p>The site is built with <a href="https://github.com/rust-lang/mdBook">mdbook</a>.</p>
<p>Let me know your feedback, suggestions or issues: <a href="https://github.com/chunliu/my-docs/issues">issues on GitHub</a></p>
<h1><a class="header" href="#tutorials---integrate-application-gateway-api-management-and-self-hosted-gateway-in-internal-virtual-network" id="tutorials---integrate-application-gateway-api-management-and-self-hosted-gateway-in-internal-virtual-network">Tutorials - Integrate Application Gateway, API Management and Self-Hosted Gateway in internal virtual network</a></h1>
<p>üìÖ 7/18/2020</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>An API Management (APIM) instance can be deployed in a virtual network (VNET) in Internal mode and then integrated with an Azure Application Gateway (AppGW) to provide access to both internal and external users. We can expand the APIM instance further with a self-hosted gateway to extend the capacity and the redundancy of the APIM.</p>
<p>In this series of tutorials, we discuss how to integrate an AppGW with an APIM instance and a self-hosted gateway in an virtual network in internal mode. You will learn the detailed process and steps, as well as things and issues you may need to pay attention.</p>
<p>The following diagram shows the components we will deploy in the tutorials. It is not meant to be a reference architecture of APIM, but just to show you what the deployment would look like. As the purpose of the tutorials is to show the possibility and how-to for such a deployment, we start the deployment from scratch and do it step by step.</p>
<p><img src="apim/images/apim-environment.png" alt="apim environment" /></p>
<p>The deployment can be automated with ARM template or Azure PowerShell modules. We use Azure Portal in the tutorials to better illustrate the process and the steps. To keep our focus on the integration of APIM and to make it easier for illustration, we only use the built-in Echo API for testing. There is no additional backend APIs in the deployment.</p>
<p>Let's begin.</p>
<h1><a class="header" href="#prepare-the-virtual-network-environment" id="prepare-the-virtual-network-environment">Prepare the virtual network environment</a></h1>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Create a virtual network with 3 subnets</li>
<li>‚úÖ Create a private DNS zone and link it to the virtual network</li>
<li>‚úÖ Create an API Management instance</li>
</ul>
<h2><a class="header" href="#create-the-virtual-network" id="create-the-virtual-network">Create the virtual network</a></h2>
<p>As the first step, we create a virtual network with 3 subnets.</p>
<ol>
<li>Open <strong>Azure Portal</strong>, click <strong>Resource Groups</strong>.</li>
<li>Click <strong>Add</strong> to add a new resource group.</li>
<li>Give the resource group a name, e.g. <code>apim-rg</code>, and choose a region such as <strong>East US</strong>. Click <strong>Review + create</strong> button, and then click <strong>Create</strong>.</li>
<li>When the resource group is create, click <strong>Go to resource group</strong> to open it.</li>
<li>On the resource group page, click <strong>Add</strong> to add a new resource.</li>
<li>In the search box, input <code>Virtual Network</code>, click it from the dropdown and click <strong>Create</strong>.</li>
<li>Give the virtual network a name, e.g. <code>apim-vnet</code>, and choose the same region of the resource group. Click <strong>Next: IP Addresses</strong>.</li>
<li>Input CIDR for <strong>IPv4 address space</strong>, such as <code>172.17.0.0/16</code>, and add the following 3 subnets.</li>
</ol>
<table><thead><tr><th>Subnet name</th><th>Subnet address range</th></tr></thead><tbody>
<tr><td>apim-subnet</td><td>172.17.0.0/24</td></tr>
<tr><td>appgw-subnet</td><td>172.17.1.0/24</td></tr>
<tr><td>aks-subnet</td><td>172.17.2.0/24</td></tr>
</tbody></table>
<ol start="9">
<li>Click <strong>Review + create</strong> and then click <strong>Create</strong> to create the virtual network.</li>
</ol>
<h2><a class="header" href="#configure-the-private-dns-zone" id="configure-the-private-dns-zone">Configure the Private DNS Zone</a></h2>
<p>When you deploy API Management in a virtual network in Internal mode, all its service endpoints are only visible within the virtual network. The default domain name of API Management, <code>azure-api.net</code>, which is managed by Azure, cannot be used to access the service endpoints anymore. As API Management service only responds to requests to the host name configured on its service endpoints and it does not listen to requests coming from IP addresses, you need to configure custom domain names for the endpoints, and therefore need a DNS service in the virtual network to manage the custom domain names.</p>
<p>In the tutorials, we use a Private DNS Zone to manage the custom domain names.</p>
<ol>
<li>In Azure Portal, go to the <strong>apim-rg</strong> resource group. Click <strong>Add</strong> to add a new resource.</li>
<li>In the search box, input <code>Private DNS Zone</code>, click it on the dropdown and click <strong>Create</strong>.</li>
<li>Make sure <strong>apim-rg</strong> is selected as the resource group.</li>
<li>Input a top level domain name for <strong>Name</strong>. For example, we use <code>contoso.net</code> for it in the tutorials.</li>
<li>Click <strong>Review + create</strong> and then click <strong>Create</strong> to create the zone.</li>
<li>When the zone is created, click <strong>Go to resource</strong> to open it.</li>
<li>Click <strong>Virtual network links</strong> and then click <strong>Add</strong> to link it to the virtual network.
<img src="apim/images/private-dns-zone.png" alt="private DNS zone" /></li>
<li>Give the link a name, e.g. <code>apim-vnet-link</code>, choose <code>apim-vnet</code> and check <strong>Enable auto registration</strong>. Click <strong>OK</strong>.</li>
</ol>
<h2><a class="header" href="#create-the-api-management-instance" id="create-the-api-management-instance">Create the API Management instance</a></h2>
<p>In the <strong>apim-rg</strong> resource group, create an API Management instance. For more details, please see <a href="https://docs.microsoft.com/azure/api-management/get-started-create-service-instance">Create a new Azure API Management service instance</a>.</p>
<p>Please make sure you choose <strong>East US</strong> for the region which is the same as the virtual network, and choose either <code>Developer</code> or <code>Premium</code> for the <strong>Pricing tier</strong>. Only these two tiers support the virtual network integration.</p>
<p>When the APIM instance is created, all steps in this tutorial are completed. Let's move to the next one.</p>
<h1><a class="header" href="#connect-api-management-to-virtual-network-in-internal-mode" id="connect-api-management-to-virtual-network-in-internal-mode">Connect API Management to virtual network in Internal mode</a></h1>
<p>In the previous tutorial, you created the virtual network, the private DNS zone and the API Management instance. In this tutorial, we continue connecting the API Management instance to the virtual network in Internal mode.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Connect the APIM instance in the virtual network in Internal mode</li>
<li>‚úÖ Create custom domain names in the private DNS zone</li>
<li>‚úÖ Create self-signed certificates with PowerShell script</li>
<li>‚úÖ Configure the APIM instance with custom domain names</li>
</ul>
<h2><a class="header" href="#connect-apim-instance-to-the-vnet-in-internal-mode" id="connect-apim-instance-to-the-vnet-in-internal-mode">Connect APIM instance to the VNET in Internal mode</a></h2>
<ol>
<li>
<p>In Azure Portal, open the APIM instance you created in the previous tutorial.</p>
</li>
<li>
<p>Click <strong>Virtual network</strong> under <strong>Deployment and infrastructure</strong> to open the VNET integration page.</p>
</li>
<li>
<p>Choose <strong>Internal</strong> for <strong>Virtual network</strong> and click the VNET option below to choose the VNET and the subnet.</p>
</li>
<li>
<p>Choose <strong>apim-vnet</strong> for the virtual network and <strong>apim-subnet</strong> for the subnet. Click <strong>Apply</strong>.</p>
<p><img src="apim/images/apim-internal-vnet.png" alt="apim internal vnet" /></p>
</li>
<li>
<p>Click <strong>Save</strong> to apply the changes. The changes could take 15 to 45 minutes to be applied.</p>
</li>
<li>
<p>When the APIM instance is deployed in the VNET successfully, you can find the <strong>private</strong> and <strong>public</strong> virtual IP addresses for the APIM instance on the <strong>Overview</strong> page. Take a note for the private IP address. We need to use it later.</p>
<p><img src="apim/images/apim-private-ip.png" alt="private IP address" /></p>
</li>
</ol>
<p>For more information about the impact of the VNET Internal mode, please see <a href="https://docs.microsoft.com/azure/api-management/api-management-using-with-internal-vnet">this document</a>.</p>
<h2><a class="header" href="#create-custom-domain-names" id="create-custom-domain-names">Create custom domain names</a></h2>
<p>With VNET Internal mode, we need to configure the APIM instance with custom domain names before we can access its service endpoints. In our scenarios, we need at least 2 domain names, one for the <strong>Gateway</strong> endpoint and the other for the <strong>Management</strong> endpoint.</p>
<ol>
<li>In Azure Portal, open the private DNS zone <strong>contoso.net</strong>.</li>
<li>Click <strong>Record set</strong> to add a new record set.</li>
<li>Create the record set with <strong>Name</strong>: <code>apim-gw</code> and <strong>IP address</strong>: <code>172.17.0.5</code> which is the private IP address we get in previous steps.
<img src="apim/images/private-zone-recordset.png" alt="record set" /></li>
<li>Repeat the steps to create another record set with <strong>Name</strong>: <code>apim-mgmt</code> and <strong>IP address</strong>: <code>172.17.0.5</code>.</li>
</ol>
<h2><a class="header" href="#create-self-signed-certificates-for-ssl" id="create-self-signed-certificates-for-ssl">Create self-signed certificates for SSL</a></h2>
<p>We also need certificates for SSL bindings of APIM. In the production environment, you should use the certificates that are trusted by your organization. We use self-signed certificates in these tutorials just for demo purpose.</p>
<p>To make things easier, we create 2 certificates with the following PowerShell script. One of the certificates is a root certificate for signing, and the other is a wildcard certificate (CN=*.contoso.net) for SSL bindings of the custom domain names.</p>
<pre><code class="language-PowerShell"># Create the root signing cert
$root = New-SelfSignedCertificate -Type Custom -KeySpec Signature `
    -Subject &quot;CN=contoso-net-signing-root&quot; -KeyExportPolicy Exportable `
    -HashAlgorithm sha256 -KeyLength 4096 `
    -CertStoreLocation &quot;Cert:\CurrentUser\My&quot; -KeyUsageProperty Sign `
    -KeyUsage CertSign -NotAfter (get-date).AddYears(5)
# Create the wildcard SSL cert.
$ssl = New-SelfSignedCertificate -Type Custom -DnsName &quot;*.contoso.net&quot;,&quot;contoso.net&quot; `
    -KeySpec Signature `
    -Subject &quot;CN=*.contoso.net&quot; -KeyExportPolicy Exportable `
    -HashAlgorithm sha256 -KeyLength 2048 `
    -CertStoreLocation &quot;Cert:\CurrentUser\My&quot; `
    -Signer $root
# Export CER of the root and SSL certs
Export-Certificate -Type CERT -Cert $root -FilePath .\contoso-signing-root.cer
Export-Certificate -Type CERT -Cert $ssl -FilePath .\contoso-ssl.cer
# Export PFX of the root and SSL certs
Export-PfxCertificate -Cert $root -FilePath .\contoso-signing-root.pfx `
    -Password (read-host -AsSecureString -Prompt &quot;password&quot;)
Export-PfxCertificate -Cert $ssl -FilePath .\contoso-ssl.pfx `
    -ChainOption BuildChain -Password (read-host -AsSecureString -Prompt &quot;password&quot;)
</code></pre>
<p>With the above script, you get the following 4 files.</p>
<ul>
<li>contoso-signing-root.cer</li>
<li>contoso-signing-root.pfx</li>
<li>contoso-ssl.cer</li>
<li>contoso-ssl.pfx</li>
</ul>
<p>Please note down the passwords you use for the PFX files. We need to use them later.</p>
<h2><a class="header" href="#configure-custom-domain-names-for-the-apim-instance" id="configure-custom-domain-names-for-the-apim-instance">Configure custom domain names for the APIM instance</a></h2>
<p>In the production environment, Azure Key Vault is recommended to manage the certificates. We use the <strong>Custom</strong> option in this tutorial. For more information about configuring custom domain, please see <a href="https://docs.microsoft.com/azure/api-management/configure-custom-domain">this document</a>.</p>
<ol>
<li>
<p>In the Azure Portal, go to the APIM instance.</p>
</li>
<li>
<p>Click <strong>Custom domains</strong> and click <strong>Add</strong>.</p>
</li>
<li>
<p>Configure the custom domain for the <strong>Gateway</strong> and <strong>Management</strong> endpoints with the following values.</p>
<p><img src="apim/images/apim-custom-domain.png" alt="custom domain" /></p>
</li>
</ol>
<table><thead><tr><th>Type</th><th>Hostname</th><th>Certificate file</th><th>Password</th><th>Default SSL binding</th></tr></thead><tbody>
<tr><td>Gateway</td><td>apim-gw.contoso.net</td><td>contoso-ssl.pfx</td><td><em>password of contoso-ssl.pfx</em></td><td>True</td></tr>
<tr><td>Management</td><td>apim-mgmt.contoso.net</td><td>contoso-ssl.pfx</td><td><em>password of contoso-ssl.pfx</em></td><td>True</td></tr>
</tbody></table>
<ol start="4">
<li>Click <strong>Save</strong> to apply the changes.</li>
</ol>
<p>The APIM instance is connected to the VNET in the Internal mode. You can move on to the next tutorial.</p>
<h1><a class="header" href="#integrate-the-apim-instance-with-application-gateway" id="integrate-the-apim-instance-with-application-gateway">Integrate the APIM instance with Application Gateway</a></h1>
<p>In the last tutorial, you connected the APIM instance to the VNET in Internal mode and configured the custom domain names for it. In this tutorial, we continue integrating the APIM instance with an Application Gateway.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Create Application Gateway</li>
<li>‚úÖ Create the custom healthy probe for APIM</li>
<li>‚úÖ Verify the integration</li>
</ul>
<h2><a class="header" href="#create-application-gateway" id="create-application-gateway">Create Application Gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, add a new resource by clicking <strong>Create a resource</strong> link.</p>
</li>
<li>
<p>Search and create <code>Application Gateway</code>.</p>
</li>
<li>
<p>Choose resource group <code>apim-rg</code>, region <code>East US</code>, and give it a name such as <code>apim-appgw</code>.</p>
</li>
<li>
<p>Choose VNET <code>apim-vnet</code> and subnet <code>appgw-subnet</code>. Click <strong>Next: Frontends</strong> button.</p>
</li>
<li>
<p>Choose <code>Public</code> for the frontend IP and create a new public IP address. And then click <strong>Next: backend</strong> button.</p>
</li>
<li>
<p>Add a backend pool as shown in the following diagram.</p>
<p><img src="apim/images/appgw-backend-pool.png" alt="AppGW backend pool" /></p>
</li>
<li>
<p>Move to <strong>Configuration</strong> and add a routing rule. The <strong>Listener</strong> of the routing rule is shown below.</p>
<p><img src="apim/images/appgw-listener.png" alt="AppGW routing rule" /></p>
</li>
<li>
<p>Choose <strong>apim-backend</strong> as the <strong>Backend target</strong>, and add a new <strong>HTTP settings</strong> as shown below. Note that <code>contoso-signing-root.cer</code> is used for <strong>CER certificate</strong> and <strong>Host name override</strong> is set to pick the name from backend.</p>
<p><img src="apim/images/appgw-http-settings.png" alt="AppGW http settings" /></p>
</li>
<li>
<p>Move to <strong>Tags</strong> and add tags if you want. Then move to <strong>Review + create</strong>.</p>
</li>
<li>
<p>Click <strong>Create</strong> to create the AppGW.</p>
</li>
</ol>
<h2><a class="header" href="#create-custom-health-probe" id="create-custom-health-probe">Create custom health probe</a></h2>
<p>When the deployment of the AppGW is completed, if you go to the resource, you would notice that the backend status is unhealthy. That is because the default probe of AppGW doesn't work for APIM. We need to create a custom health probe for it.</p>
<p><img src="apim/images/appgw-default-probe.png" alt="AppGW default probe" /></p>
<ol>
<li>
<p>Click <strong>Health probes</strong> and click <strong>Add</strong> to add a custom health probe. The details of the custom health probe are shown in the diagram below. Note the <strong>Protocol</strong> and host name settings. The <strong>Path</strong> of the APIM probe is <code>/status-0123456789abcdef</code>.</p>
<p><img src="apim/images/appgw-custom-probe.png" alt="AppGW custom probe" /></p>
</li>
<li>
<p>Uncheck <strong>I want to test the backend health before adding the health probe</strong> option and click <strong>Add</strong>.</p>
</li>
<li>
<p>Go to <strong>Backend health</strong> and refresh. The status of the backend should be <strong>Healthy</strong> now.</p>
<p><img src="apim/images/appgw-custom-probe-healthy.png" alt="AppGW healthy probe" /></p>
</li>
</ol>
<h2><a class="header" href="#verify-the-integration" id="verify-the-integration">Verify the integration</a></h2>
<p>We can verify if the integration works by sending a request to the public IP address of the AppGW. We do it with <a href="https://docs.microsoft.com/azure/cloud-shell/overview">Azure Cloud Shell</a> in this tutorial. You can also do it with other tools such as Postman.</p>
<ol>
<li>
<p>In the Azure Portal, open Azure Cloud Shell. Choose <strong>Bash</strong> for the shell.</p>
</li>
<li>
<p>Run the following command with <code>curl</code>. You can find the <a href="https://docs.microsoft.com/azure/api-management/api-management-subscriptions">subscription</a> key of APIM on the <strong>Subscriptions</strong> page of APIM, and the public IP address of AppGW on the <strong>Overview</strong> page of AppGW.</p>
<pre><code class="language-bash">curl -I -H &quot;Ocp-Apim-Subscription-Key: [subscription key]&quot; http://[AppGW public IP]/echo/resource
</code></pre>
</li>
<li>
<p>If everything works, you get <code>HTTP 200 OK</code> in the response.</p>
</li>
</ol>
<p>Now you've integrated the APIM instance with an AppGW. Let's move on to the next tutorial to expand the deployment further with a self-hosted gateway.</p>
<h1><a class="header" href="#deploy-self-hosted-gateway" id="deploy-self-hosted-gateway">Deploy self-hosted gateway</a></h1>
<p>In the previous tutorials, you've deployed the APIM instance in the internal VNET and integrated it with the AppGW. In this tutorial, we expand the deployment with a <a href="https://docs.microsoft.com/azure/api-management/self-hosted-gateway-overview">self-hosted gateway</a> to extend the capacity and redundancy of the APIM instance.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Deploy an Azure Kubernetes Service (AKS) cluster in the VNET</li>
<li>‚úÖ Deploy a self-hosted gateway in the AKS cluster</li>
</ul>
<h2><a class="header" href="#deploy-an-aks-cluster-to-host-the-self-hosted-gateway" id="deploy-an-aks-cluster-to-host-the-self-hosted-gateway">Deploy an AKS cluster to host the self-hosted gateway</a></h2>
<p>The self-hosted gateway of APIM is a containerized, functionally-equivalent version of the managed gateway that is part of every APIM service deployed. It can be deployed to Docker, Kubernetes, or any other container orchestration solution running on a server cluster on premises, cloud infrastructure, or for evaluation and development purposes, on a personal computer. In this tutorial, we deploy an AKS cluster to host the self-hosted gateway.</p>
<h3><a class="header" href="#create-a-service-principal-and-assign-permissions" id="create-a-service-principal-and-assign-permissions">Create a service principal and assign permissions</a></h3>
<p>To allow the AKS cluster to access the VNET and subnet, we need to configure it with a <a href="https://docs.microsoft.com/azure/active-directory/develop/app-objects-and-service-principals#service-principal-object">service principal</a>.</p>
<ol>
<li>
<p>In the Azure Portal, open Cloud Shell and choose <strong>Bash</strong> as the shell.</p>
</li>
<li>
<p>Run the following command to create the service principal and take a note on the output. We need to use it later.</p>
<pre><code class="language-bash">az ad sp create-for-rbac --skip-assignment
</code></pre>
</li>
<li>
<p>Assign the service principal <strong>Network Contributor</strong> role to the VNET with the following command. <code>&lt;appId&gt;</code> is the value of <code>appId</code> from the output of the above step.</p>
<pre><code class="language-bash">VNET_ID=$(az network vnet show --resource-group apim-rg --name apim-vnet --query id -o tsv)
az role assignment create --assignee &lt;appId&gt; --scope $VNET_ID --role &quot;Network Contributor&quot;
</code></pre>
</li>
</ol>
<h3><a class="header" href="#deploy-the-aks-cluster-with-azure-portal" id="deploy-the-aks-cluster-with-azure-portal">Deploy the AKS cluster with Azure Portal</a></h3>
<p>We deploy the AKS cluster to the VNET and the corresponding subnet. For details about the AKS networking, please see <a href="https://docs.microsoft.com/azure/aks/configure-kubenet">this document</a>.</p>
<ol>
<li>
<p>In the Azure Portal, add a new resource to the <strong>apim-rg</strong> resource group.</p>
</li>
<li>
<p>Search <code>Kubernetes Service</code> and click <strong>Create</strong>.</p>
</li>
<li>
<p>Choose resource group <code>apim-rg</code>, region <code>East US</code> and give the cluster a name such as <code>apim-aks</code>. Accept other default settings and move to <strong>Next: Node pools</strong>.</p>
</li>
<li>
<p>Accept default settings for node pools and move to <strong>Next: Authentication</strong>.</p>
</li>
<li>
<p>Choose <strong>Service principal</strong> as the <strong>Authentication method</strong> and click <strong>Configure service principal</strong> to configure it.</p>
</li>
<li>
<p>Choose <strong>Use existing</strong>, and input the <strong>client ID</strong> and <strong>client secret</strong>. They are the values of <strong>appID</strong> and <strong>password</strong> from the output of creating the service principal command.</p>
<p><img src="apim/images/aks-service-principal.png" alt="aks service principal" /></p>
</li>
<li>
<p>Move to <strong>Next: Networking</strong>.</p>
</li>
<li>
<p>Choose <strong>Advanced</strong> for <strong>Network configuration</strong> option and apply the settings as shown in the diagram below.</p>
<p><img src="apim/images/aks-vnet.png" alt="aks vnet" /></p>
</li>
<li>
<p>Click <strong>Review + create</strong> and then click <strong>Create</strong> to deploy the AKS cluster.</p>
</li>
<li>
<p>When the deployment is completed, open Cloud Shell and run the following command. Make sure the cluster info of the AKS cluster can be shown.</p>
<pre><code class="language-bash">az aks get-credentials --resource-group apim-rg --name apim-aks
kubectl cluster-info
</code></pre>
</li>
</ol>
<h2><a class="header" href="#deploy-the-self-hosted-gateway" id="deploy-the-self-hosted-gateway">Deploy the self-hosted gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, go to the API Management.</p>
</li>
<li>
<p>Click <strong>Gateways</strong> and click <strong>Add</strong> to add a self-hosted gateway as shown below.</p>
<p><img src="apim/images/apim-add-shgw.png" alt="add self-hosted gateway" /></p>
</li>
<li>
<p>When the gateway is added, click it to open its settings.</p>
</li>
<li>
<p>Click <strong>Deployment</strong> and then click <strong>Kubernetes</strong>.</p>
</li>
</ol>
<p>In normal cases, we can use the yaml to deploy the gateway straightly. But as we are in an internal VNET environment, we need to make some changes to the yaml before it can be deployed.</p>
<ol start="5">
<li>
<p>Open the Cloud Shell. Copy and run the following command to create the secret for the gateway key in AKS first.</p>
<p><img src="apim/images/shgw-secret.png" alt="secret for shgw key" /></p>
</li>
</ol>
<p>As we are using custom domain names and self-signed SSL certificate, the certificate needs to be trusted by the self-hosted gateway. We create a configMap to install the certificate to the gateway pod.</p>
<blockquote>
<p>In production environment, you would want to use more secured options, such as Pod Identity and Azure Key Vault, to manage the certificates.</p>
</blockquote>
<ol start="6">
<li>
<p>In the Cloud Shell, upload <strong>contoso-signing-root.cer</strong>.</p>
<p><img src="apim/images/cloud-shell-upload.png" alt="cloud shell upload" /></p>
</li>
<li>
<p>Convert the CER to PEM before it can be used for the gateway pod.</p>
<pre><code class="language-bash">openssl x509 -inform der -in contoso-signing-root.cer -out contoso-signing-root.pem
</code></pre>
</li>
<li>
<p>Create a configMap in the AKS for the certificate.</p>
<pre><code class="language-bash">kubectl create configmap signing-root --from-file=contoso-signing-root.pem
</code></pre>
</li>
</ol>
<p>We need to make 3 changes to the yaml file generated by APIM.</p>
<ul>
<li>Change the <strong>config.service.endpoint</strong> to use the custom domain name of the management service endpoint.</li>
<li>Install the certificate to the pod so that it can be trusted by the pod.</li>
<li>Use an <a href="https://docs.microsoft.com/azure/aks/internal-lb">internal load balancer</a> to expose the gateway service.</li>
</ul>
<ol start="9">
<li>
<p>Open the editor of the Cloud Shell, and then copy and paste the content of the yaml generated by APIM to it.</p>
<p><img src="apim/images/cloud-shell-editor.png" alt="cloud shell editor" /></p>
</li>
<li>
<p>Change the domain name of <strong>config.service.endpoint</strong> to <code>apim-mgmt.contoso.net</code>.</p>
</li>
<li>
<p>Add the annotation for the internal load balancer, <code>service.beta.kubernetes.io/azure-load-balancer-internal: &quot;true&quot;</code>, to the service.</p>
</li>
<li>
<p>Create a volume based on the configMap <code>signing-root</code> and mount the <code>contoso-signing-root.pem</code> from it. The complete code of the yaml is shown below.</p>
<blockquote>
<p>Note that you need to change the <code>&lt;subscription id&gt;</code> in <strong>config.service.endpoint</strong>.</p>
</blockquote>
<pre><code class="language-yml"># NOTE: Before deploying into production please review documentation -&gt; https://aka.ms/self-hosted-gateway-production
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: apim-shgw-env
data: # change to the domain name of management endpoint
  config.service.endpoint: &quot;https://apim-mgmt.contoso.net/subscriptions/&lt;subscription id&gt;/resourceGroups/apim-rg/providers/Microsoft.ApiManagement/service/apiminst32?api-version=2019-12-01&quot;
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: apim-shgw
spec:
  replicas: 1
  selector:
    matchLabels:
      app: apim-shgw
  template:
    metadata:
      labels:
        app: apim-shgw
    spec:
      containers:
      - name: apim-shgw
        image: mcr.microsoft.com/azure-api-management/gateway:latest
        ports:
        - name: http
          containerPort: 8080
        - name: https
          containerPort: 8081
        env:
        - name: config.service.auth
          valueFrom:
            secretKeyRef:
              name: apim-shgw-token
              key: value
        envFrom:
        - configMapRef:
            name: apim-shgw-env
        volumeMounts: # mount the signing certificate
        - name: signing-root-volume
          mountPath: /etc/ssl/certs/contoso-signing-root.pem
          subPath: contoso-signing-root.pem
          readOnly: false
      volumes:
      - name: signing-root-volume
        configMap:
          name: signing-root
---
apiVersion: v1
kind: Service
metadata:
  name: apim-shgw
  annotations: # use internal load balancer
    service.beta.kubernetes.io/azure-load-balancer-internal: &quot;true&quot;
spec:
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: https
    port: 443
    targetPort: 8081
  selector:
    app: apim-shgw
</code></pre>
</li>
<li>
<p>Save the yaml to a file, <code>apim-shgw.yaml</code>, and run the following command to deploy it.</p>
<pre><code class="language-bash">kubectl apply -f ./apim-shgw.yaml
</code></pre>
</li>
<li>
<p>When the self-hosted gateway is deployed successfully, you would see 1 node in the status of the self-hosted gateway in the Azure Portal.</p>
<p><img src="apim/images/shgw-deploy-success.png" alt="gateway deployed successfully" /></p>
<blockquote>
<p>In case if the deployment is completed but the node in the status keeps showing 0, you can check the log of pod with <code>kubectl logs &lt;pod-name&gt;</code> to find out what is wrong. Possible reasons could be the URL of the management endpoint is incorrect or the root certificate is not installed properly.</p>
</blockquote>
</li>
</ol>
<p>In the next tutorial, we will integrate the self-hosted gateway with the Application Gateway.</p>
<h1><a class="header" href="#integrate-application-gateway-with-the-self-hosted-gateway" id="integrate-application-gateway-with-the-self-hosted-gateway">Integrate Application Gateway with the self-hosted gateway</a></h1>
<p>In the previous tutorial, you've deployed the self-hosted gateway in the AKS cluster. In this tutorial, you continue integrating it with the Application Gateway which is the last piece of the puzzle.</p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Configure the domain name for the self-hosted gateway</li>
<li>‚úÖ Integrate the AppGW with the self-hosted gateway</li>
</ul>
<h2><a class="header" href="#configure-the-domain-name-for-the-self-hosted-gateway" id="configure-the-domain-name-for-the-self-hosted-gateway">Configure the domain name for the self-hosted gateway</a></h2>
<p>Before the self-hosted gateway can be added to the backend pool of the AppGW, you need to configure a custom domain name for it.</p>
<ol>
<li>
<p>Open Cloud Shell and run the following command to find the IP address of the self-hosted gateway service.</p>
<pre><code class="language-bash">kubectl get service
</code></pre>
</li>
<li>
<p>Take a note of the <strong>External-IP</strong> address of <strong>apim-shgw</strong> service.</p>
<blockquote>
<p>The external IP of the service is within the address space of the VNET because we used an internal load balancer for it.</p>
</blockquote>
<p><img src="apim/images/shgw-service-ip.png" alt="service ip" /></p>
</li>
<li>
<p>In the Azure Portal, go to the private DNS zone <code>contoso.net</code>, add a new record set and point it to the IP address of the gateway service, as shown below.</p>
<p><img src="apim/images/shgw-record-set.png" alt="shgw record set" /></p>
</li>
<li>
<p>Go to API Management in the Azure Portal.</p>
</li>
<li>
<p>Click <strong>Certificates</strong> and click <strong>Add</strong> to add the SSL certificate.</p>
</li>
<li>
<p>Add <code>contoso-ssl.pfx</code>, as shown below.</p>
<p><img src="apim/images/apim-add-cert.png" alt="apim add cert" /></p>
</li>
<li>
<p>Open the self-hosted gateway settings by clicking <strong>Gateways</strong> and the gateway.</p>
</li>
<li>
<p>Click <strong>Hostnames</strong> and click <strong>Add</strong> to add a new host name for the gateway.</p>
<p><img src="apim/images/shgw-hostname.png" alt="shgw host name" /></p>
</li>
</ol>
<h2><a class="header" href="#integrate-appgw-with-the-self-hosted-gateway" id="integrate-appgw-with-the-self-hosted-gateway">Integrate AppGW with the self-hosted gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, go to Application Gateway.</p>
</li>
<li>
<p>Click <strong>Backend pools</strong> and the existing backend pool <strong>apim-backend</strong>.</p>
</li>
<li>
<p>Add <code>apim-shgw.contoso.net</code> as a new type of <strong>IP address or FQDN</strong> target.</p>
</li>
<li>
<p>When the backend target is added to the backend pool, click <strong>Health probes</strong> and the existing custom probe <strong>apim-probe</strong>.</p>
</li>
<li>
<p>Update the <strong>Path</strong> from <code>/status-0123456789abcdef</code> to <code>/internal-status-0123456789abcdef</code>. Uncheck <strong>I want to test the backend health before adding the health probe</strong> and click <strong>Save</strong> to save the changes.</p>
<blockquote>
<p>At the moment, the documented probe path of APIM, <code>/status-0123456789abcdef</code>, doesn't work for the self-hosted gateway. <code>/internal-status-0123456789abcdef</code> is an undocumented probe path which works for both APIM and the self-hosted gateway temporarily. The APIM product team is working on an update of the probe path for the self-hosted gateway. You need to update the path again when the update is available.</p>
</blockquote>
</li>
<li>
<p>Click <strong>Backend health</strong> to check the health of the backend. You should see both targets are healthy.</p>
<p><img src="apim/images/appgw-both-backend-healthy.png" alt="app gateway both backend targets are healthy" /></p>
</li>
</ol>
<p>At this point, you've completed all tasks and steps that are needed to integrate Application Gateway, API Management and Self-Hosted Gateway in and internal virtual network.</p>
<p>Move on to the last tutorial of this series, we will run a quick test to see how the whole environment works.</p>
<h1><a class="header" href="#verify-the-deployment" id="verify-the-deployment">Verify the deployment</a></h1>
<p>In the previous tutorials, you've deployed the following environment in Azure. In this tutorial, we test if the deployment works as expected, and if the requests can be load balanced and handled by both APIM and the self-hosted gateway.</p>
<p><img src="apim/images/apim-environment.png" alt="architecture" /></p>
<p>In this tutorial, you learn to:</p>
<ul>
<li>‚úÖ Send requests to API Management through Application Gateway</li>
<li>‚úÖ Verify if the requests are distributed to both API Managenet and the self-hosted gateway</li>
</ul>
<h2><a class="header" href="#send-requests-through-application-gateway" id="send-requests-through-application-gateway">Send requests through Application Gateway</a></h2>
<ol>
<li>
<p>In the Azure Portal, open Azure Cloud Shell. Choose <strong>Bash</strong> for the shell.</p>
</li>
<li>
<p>Run the following command with <code>curl</code>. You can find the <a href="https://docs.microsoft.com/azure/api-management/api-management-subscriptions">subscription</a> key of APIM on its <strong>Subscriptions</strong> page, and the public IP address of AppGW on its <strong>Overview</strong> page.</p>
<pre><code class="language-bash">curl -I -H &quot;Ocp-Apim-Subscription-Key: [subscription key]&quot; http://[AppGW public IP]/echo/resource
</code></pre>
</li>
<li>
<p>If everything works, you get <code>HTTP 200 OK</code> in the response.</p>
</li>
</ol>
<h2><a class="header" href="#test-if-the-requests-are-distributed-to-both-apim-and-the-self-hosted-gateway" id="test-if-the-requests-are-distributed-to-both-apim-and-the-self-hosted-gateway">Test if the requests are distributed to both APIM and the self-hosted gateway</a></h2>
<p>To test if the requests are handled by either APIM or the self-hosted gateway, you can send HTTP header <code>Ocp-Apim-Trace</code> to enable the trace of APIM. To make the verification even more intuitive, we use a custom policy to retrieve the host from APIM.</p>
<ol>
<li>
<p>In the Azure Portal, go to API Management.</p>
</li>
<li>
<p>Click <strong>APIs</strong> &gt; <strong>Echo API</strong> &gt; <strong>All operations</strong>.</p>
</li>
<li>
<p>Click <strong>&lt;/&gt;</strong> on the <strong>Inbound processing</strong> card to open the policy editor.</p>
</li>
<li>
<p>Replace the code in the policy editor with the code below.</p>
<pre><code class="language-xml">&lt;policies&gt;
    &lt;inbound&gt;
        &lt;base /&gt;
        &lt;set-variable name=&quot;inbound-host&quot; value=&quot;@(context.Request.Headers.GetValueOrDefault(&quot;Host&quot;))&quot; /&gt;
    &lt;/inbound&gt;
    &lt;backend&gt;
        &lt;base /&gt;
    &lt;/backend&gt;
    &lt;outbound&gt;
        &lt;base /&gt;
        &lt;set-header name=&quot;apim-host&quot; exists-action=&quot;override&quot;&gt;
            &lt;value&gt;@((string)context.Variables[&quot;inbound-host&quot;])&lt;/value&gt;
        &lt;/set-header&gt;
    &lt;/outbound&gt;
    &lt;on-error&gt;
        &lt;base /&gt;
    &lt;/on-error&gt;
&lt;/policies&gt;
</code></pre>
</li>
<li>
<p>In the Cloud Shell, run the same <code>curl</code> command as shown in the previous section. Run the command multiple times. You'll notice that the <code>apim-header</code> in the response could be either <code>apim-gw.contoso.net</code>, which is the APIM instance, or <code>apim-shgw.contoso.net</code>, which is the self-hosted gateway. AppGW uses the round robin to distribute the requests to both of them.</p>
<p><img src="apim/images/nlb-verification.png" alt="nlb verification" /></p>
</li>
</ol>
<p>You've completed this series of tutorials. Congratulations! üéâ</p>
<h1><a class="header" href="#spring-boot-mysql-and-azure-app-service---what-azure-would-look-like-for-java-developers" id="spring-boot-mysql-and-azure-app-service---what-azure-would-look-like-for-java-developers">Spring Boot, MySQL and Azure App Service - What Azure would look like for Java developers</a></h1>
<p>üìÖ 2/7/2019</p>
<blockquote>
<p>This is the lab content that I created for a session that I delivered in the Microsoft Ready 2019 in Seattle.</p>
</blockquote>
<p>This technical lab is designed for you to experience building Java applications, deploying and running them on Azure. It consists of several exercises which are step by step tutorials that you can follow easily. The lab is focused on <strong>developing</strong> Java applications with Microsoft tools such as Visual Studio Code, <strong>deploying</strong> the applications to App Service on Linux, and <strong>implementing</strong> Continuous Integration/Continuous Delivery (CI/CD) with Azure Pipelines. </p>
<h2><a class="header" href="#objectives" id="objectives">Objectives</a></h2>
<p>As a result of working through this lab, you will</p>
<ul>
<li>get real experience in developing Java applications with VSCode, Azure DevOps and App Service.</li>
<li>be better able to articulate the Azure DevOps CI/CD experience for Java applications.</li>
<li>be better able to understand the basics of Spring Boot framework and MySQL database.</li>
</ul>
<h2><a class="header" href="#exercise-0---familiar-with-the-lab-environment" id="exercise-0---familiar-with-the-lab-environment">Exercise 0 - Familiar with the lab environment</a></h2>
<p>In this exercise, we will check the environment settings on the lab machine to make sure it is ready for the lab. After completing the exercise, you will know the basic environment settings which are required for the Java development on Windows.</p>
<h3><a class="header" href="#01---java-settings" id="01---java-settings">0.1 - Java settings</a></h3>
<p>In this lab, we will use <a href="https://openjdk.java.net/">OpenJDK</a> and <a href="https://maven.apache.org/what-is-maven.html">Maven</a> to develop and build Java applications. Both of these two components have been installed and configured on the lab machine. You can follow the steps below to check the settings to make sure they are working.</p>
<ol>
<li>
<p>On the lab machine, click the <strong>Command Prompt</strong> icon on Windows task bar to launch the Command Prompt.</p>
</li>
<li>
<p>In the Command Prompt window, run command <code>java --version</code> followed by <code>mvn --version</code>.</p>
</li>
<li>
<p>The output in the Command Prompt should look like the following screenshot.</p>
<p><img src="appservice/images/ex0/java-settings.png" alt="Java settings" /></p>
</li>
</ol>
<p>If you can see the similar output as shown in the above screenshot, the Java settings are correct.</p>
<h3><a class="header" href="#02---local-mysql-instance" id="02---local-mysql-instance">0.2 - Local MySQL instance</a></h3>
<p>On the lab machine, MySQL is installed and a local instance is configured. We will use it as the local database engine for testing purpose when we develop Java applications. Please follow the steps below to verify the local instance of MySQL is working.</p>
<ol>
<li>
<p>On the lab machine, click the <strong>MySQL Workbench</strong> icon <img src="appservice/images/ex0/mysql-wb-icon.png" alt="MySQL Workbench icon" /> on Windows task bar to launch it.</p>
</li>
<li>
<p>In the window of MySQL Workbench, click <strong>Local instance MySQL80</strong>, as shown in the screenshot below, input the password <code>P@ssw0rd1</code> and click <strong>OK</strong> button.</p>
<p><img src="appservice/images/ex0/mysql-wb-connect.png" alt="MySQL Workbench connection" /></p>
</li>
<li>
<p>If the local MySQL instance is working well, the Workbench should connect to it successfully, and you should see the Server Status as <strong>Running</strong> when you click the <strong>Server Status</strong> on the left Navigator.</p>
</li>
<li>
<p>Let's create a new database that we will use in the later exercises. In the <strong>Query 1</strong> window, run the following T-SQL to create a new database.</p>
<pre><code class="language-sql">create database tododb;
</code></pre>
</li>
<li>
<p>Close MySQL Workbench after you finish the exercise.</p>
</li>
</ol>
<h3><a class="header" href="#03---azure-database-for-mysql" id="03---azure-database-for-mysql">0.3 - Azure Database for MySQL</a></h3>
<p>In this lab, we will use Azure Database for MySQL as our database engine. There is an Azure Database for MySQL instance in your Azure subscription. We need to prepare the database on it for our code. </p>
<ol>
<li>
<p>Open browser and explore <a href="https://portal.azure.com">https://portal.azure.com</a>, sign in with the Azure account provided. </p>
</li>
<li>
<p>Click <strong>Resource groups &gt; <em>[the name of the resource group]</em></strong>. You will see 4 resources which look similar to the following screenshot.</p>
<p><img src="appservice/images/ex0/azure-resources.png" alt="Azure Resources" /></p>
</li>
<li>
<p>Click the name of Azure Database for MySQL server to view its details. </p>
</li>
<li>
<p>Click Cloud Shell button <img src="appservice/images/ex0/cloud-shell.png" alt="Cloud Shell" /> to open the cloud shell. Select <strong>Bash</strong> as the shell environment. </p>
<blockquote>
<p>[!NOTE]
You might have to initialize the Cloud Shell and configure the storage account that it needs to use. If prompt, choose <strong>Show advanced settings</strong>, and then choose to use <strong>existing</strong> resource group and storage account, and create a new file share. See screenshot below as a reference. 
<img src="appservice/images/ex0/cloud-shell-init.png" alt="Initialize cloud shell" /></p>
</blockquote>
</li>
<li>
<p>In cloud shell window, connect to MySQL server with the following command: </p>
<pre><code class="language-console">mysql --host [mysql server name].mysql.database.azure.com --user dbadmin@[mysql server name] -p
</code></pre>
<p>You can find <em>[mysql server name]</em> from the <strong>Overview</strong> page of your Azure MySQL instance. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex0/mysql-signin.png" alt="MySQL sign in" /></p>
</li>
<li>
<p>When prompt, type the password <code>P@ssw0rd1</code>. </p>
</li>
<li>
<p>When you connect to MySQL server successfully, type the following command to view all existing databases. </p>
<pre><code class="language-sql">show databases;
</code></pre>
</li>
<li>
<p>Type the following SQL script to prepare for the database that we will use in our code later. </p>
<pre><code class="language-sql">CREATE DATABASE tododb;
CREATE USER 'springuser'@'%' IDENTIFIED BY 'Spring1234';
GRANT ALL PRIVILEGES ON tododb.* TO 'springuser'@'%';
FLUSH PRIVILEGES;
</code></pre>
</li>
<li>
<p>After running the above script, if you run <code>show databases;</code> again, you will see a new database created. </p>
</li>
<li>
<p>Type <code>quit;</code> to close the connection, and then close the cloud shell window. </p>
</li>
<li>
<p>Click <strong>Connection security</strong> of Azure MySQL instance, turn on <strong>Allow access to Azure services</strong> and click <strong>Save</strong>. See screenshot below. </p>
<p><img src="appservice/images/ex0/mysql-conn-sec.png" alt="Connection security" /></p>
</li>
</ol>
<h3><a class="header" href="#04---extensions-of-visual-studio-code" id="04---extensions-of-visual-studio-code">0.4 - Extensions of Visual Studio Code</a></h3>
<p>In this lab, we will use <a href="https://code.visualstudio.com/docs">Visual Studio Code</a> as our development environment for Java applications. The Java language support in Visual Studio Code is provided through a set of extensions. You can view these extensions in Visual Studio Code. For more information about using Java in VS Code, please see <a href="https://code.visualstudio.com/docs/languages/java">Java in Visual Studio Code</a>.</p>
<ol>
<li>Open VSCode by clicking its icon <img src="appservice/images/ex0/vscode-icon.png" alt="vscode icon" /> on Windows task bar.</li>
<li>Open the extensions panel by clicking its icon or press <code>Ctrl+Shift+X</code>. You should see all extensions that are required by this lab.</li>
</ol>
<h2><a class="header" href="#exercise-1---build-a-sprint-boot-web-app-in-vs-code" id="exercise-1---build-a-sprint-boot-web-app-in-vs-code">Exercise 1 - Build a Sprint Boot web app in VS Code</a></h2>
<p>In this exercise, we will create a Sprint Boot project with VS Code from scratch. We will also run the code and debug it in VS Code. After completing the exercise, you will better understand the developer experience that VS Code provides to Java developers. </p>
<h3><a class="header" href="#11---create-a-sprint-boot-project-in-vs-code" id="11---create-a-sprint-boot-project-in-vs-code">1.1 - Create a Sprint Boot project in VS Code</a></h3>
<p>Please follow the steps below to create a Sprint Boot project in VS Code from scratch.</p>
<ol>
<li>
<p>Open VS Code. If there is any folder opened in VS Code, close it by clicking <strong>File &gt; Close Folder</strong> or pressing <code>Ctrl+K F</code>.</p>
</li>
<li>
<p>In VS Code, open Command Palette by clicking <strong>View &gt; Command Palette</strong> or pressing <code>Ctrl+Shift+P</code>.</p>
</li>
<li>
<p>In Command Palette, input <code>Spring</code> and then select <strong>Spring Initializr: Generate a Maven Project</strong>. See screenshot below for a reference.</p>
<p><img src="appservice/images/ex1/create-project-1.png" alt="Spring Initializr" /></p>
</li>
<li>
<p>Follow the steps of Spring Initializr wizard with the following values.</p>
<p>|Properties  |Value           |
|------------|----------------|
|Language    |Java            |
|Group Id    |com.azurelabs   |
|Artifact Id |hellospringboot |
|Version     |2.1.1           |</p>
</li>
<li>
<p>For dependencies, select <strong>DevTools</strong> and <strong>Web</strong>. See screenshot below.</p>
<p><img src="appservice/images/ex1/create-project-2.png" alt="Select dependencies" /></p>
</li>
<li>
<p>In the Select Folder window, select <code>C:\Code</code> as the folder and click <strong>Generate into this folder</strong> button.</p>
</li>
<li>
<p>Once the project is generated, click <strong>Open</strong> button on the popup in VS Code to open the folder in VS Code.</p>
<p><img src="appservice/images/ex1/create-project-3.png" alt="Popup" /></p>
</li>
</ol>
<p>By following the Spring Initializr wizard, a Spring Boot project is created. This is an empty project. It provides us a project structure based on which we can build our applications. The folder structure of the project is the typical structure of Maven projects.</p>
<h3><a class="header" href="#12---implement-a-web-controller" id="12---implement-a-web-controller">1.2 - Implement a web controller</a></h3>
<p>Let's add a simple web controller to handle the web request. </p>
<ol>
<li>
<p>In VS Code, create a new file, <code>HelloController.java</code>, in the folder <strong>src/main/java/com/azurelabs/hellospringboot</strong>.</p>
</li>
<li>
<p>In this new file, write the following code: </p>
<blockquote>
<p>[!NOTE]
Type the code to try the Java coding experience in VS Code. </p>
</blockquote>
<pre><code class="language-java">package com.azurelabs.hellospringboot;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @RequestMapping(&quot;/&quot;)
    public String Index() {
        return &quot;Hello, Spring Boot!&quot;;
    }
}
</code></pre>
</li>
<li>
<p>With the above code, we have a simple web controller that can handle the request. To test the application locally, open the Terminal in VS Code by clicking <strong>View &gt; Terminal</strong> or pressing <code>Ctrl+` </code>.</p>
</li>
<li>
<p>In the Terminal, run command <code>.\mvnw spring-boot:run</code>. This command will compile the code and run it. </p>
</li>
<li>
<p>When the project is running successfully, you will see the output in the Terminal which is similar as <em>Started DemoApplication in 11.869 seconds (JVM running for 13.251)</em>. </p>
</li>
<li>
<p>Open a browser and visit <code>http://localhost:8080</code>. You should see a simple page as shown in the screenshot below. </p>
<p><img src="appservice/images/ex1/browser-simplepage.png" alt="Hello, Spring Boot" /></p>
</li>
<li>
<p>Close the browser, and stop the application by pressing <code>Ctrl+C</code> in Terminal. </p>
</li>
</ol>
<h3><a class="header" href="#13---debug-the-java-code-in-vs-code" id="13---debug-the-java-code-in-vs-code">1.3 - Debug the Java code in VS Code</a></h3>
<p>To debug the Java application locally in VS Code, we need to configure the <code>launch.json</code>. Fortunately, VS Code has made it very easy for us to configure it. </p>
<ol>
<li>
<p>In VS Code, click Debug icon on the left navigation or press <code>Ctrl+Shift+D</code> to open the Debug Panel. </p>
</li>
<li>
<p>Click the <strong>Configure</strong> button to generate a launch.json file. See screenshot below for details. VS Code helps us generate the launch.json automatically based on the project settings.</p>
<p><img src="appservice/images/ex1/debug-configure.png" alt="Configure debug" /></p>
</li>
<li>
<p>Open <code>HelloController.java</code> and set a breakpoint on the code, <code>return &quot;Hello, Spring Boot!&quot;;</code>. </p>
</li>
<li>
<p>Press <code>F5</code> or click <strong>Start Debugging</strong> button on the Debug Panel. </p>
</li>
<li>
<p>When the application is running, open a browser and visit <code>http://localhost:8080</code>. The breakpoint should be hit, as shown in the screenshot below. Press <code>F5</code> or click <strong>Continue</strong> and you will see the page in the browser. </p>
<p><img src="appservice/images/ex1/debug-bp.png" alt="Hit breakpoint" /></p>
</li>
<li>
<p>Stop the debugging by clicking <strong>Stop</strong> button or pressing <code>Shift+F5</code>. </p>
</li>
</ol>
<p>Close VS Code and browser window after you complete the exercise. </p>
<h2><a class="header" href="#exercise-2---run-a-spring-boot-web-app-on-azure" id="exercise-2---run-a-spring-boot-web-app-on-azure">Exercise 2 - Run a Spring Boot web app on Azure</a></h2>
<p>In this exercise, let's switch the gear and create a simple web app with Spring Boot and MySQL, and then publish it to an Azure website. For the sake of time, let's get the completed code from the GitHub repository. </p>
<h3><a class="header" href="#21---clone-the-github-repository-and-build-the-project-locally" id="21---clone-the-github-repository-and-build-the-project-locally">2.1 - Clone the GitHub repository and build the project locally</a></h3>
<p>To clone the project, follow the steps below. </p>
<ol>
<li>
<p>In the lab machine, launch the <strong>Command Prompt</strong>. Switch the work directory to <strong>C:\Code</strong> by typing the command: <code>cd C:\Code</code>.</p>
</li>
<li>
<p>Clone the repository with the command: <code>git clone https://github.com/chunliu/todowebjava.git</code>. When the clone completes, the output in the Command Prompt looks like the following screenshot, and a new folder, <strong>todowebjava</strong>, is created in C:\Code.</p>
<p><img src="appservice/images/ex2/clone.png" alt="Clone the repository" /></p>
</li>
<li>
<p>In the Command Prompt, type <code>cd todowebjava</code> to go into the folder, and then type <code>code .</code> to open the folder in VS Code. </p>
</li>
<li>
<p>Explore the project structure and the Java code in the folder <strong>src/main/java/com/azurelabs/todowebjava</strong>. This project uses <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a> to read and persist data to MySQL database. </p>
</li>
<li>
<p>Let's configure the database connection in the project before we run it. Open <strong>application.properties</strong> file in <strong>src/main/resources</strong> folder. </p>
</li>
<li>
<p>Replace the following values in the application.properties file according to the table below, and save the changes. <strong>Don't change other settings in this file</strong>. </p>
<p>|Property Name |Old Value |New Value |
|---------|---------|---------|
|spring.datasource.url |${SPRING_DATASOURCE_URL} |jdbc:mysql://localhost:3306/tododb?serverTimezone=UTC |
|spring.datasource.username |${SPRING_DATASOURCE_USERNAME} |root |
|spring.datasource.password |${SPRING_DATASOURCE_PASSWORD} |P@ssw0rd1 |
|server.port |${PORT} |80 |</p>
</li>
<li>
<p>Now we can test if it works. In VS Code, press <code>F5</code> to launch the web app. When it is launched successfully, open a browser and explore <code>http://localhost</code>. You should see the home page of the todo web app.</p>
</li>
<li>
<p>Let's create a new todo item in the web app. In the browser window, click <strong>Todo</strong> on the left navigation, and then click <strong>New Task</strong>. </p>
</li>
<li>
<p>In the pop up, input a name for the task, for example, <code>A new task</code>, and click <strong>OK</strong>. A new task should be created accordingly. </p>
</li>
<li>
<p>To verify if the data has been persisted in the database, you can open the MySQL Workbench, connect to the MySQL instance, and run the following query. You should see 1 record in the database. </p>
<pre><code class="language-sql">use tododb;
select * from todo_item;
</code></pre>
</li>
</ol>
<h3><a class="header" href="#22---publish-the-web-app-to-azure-app-service" id="22---publish-the-web-app-to-azure-app-service">2.2 - Publish the web app to Azure App Service</a></h3>
<p>Follow the steps below to update the code and publish the web app to the Azure App Service. </p>
<ol>
<li>
<p>In VS Code, open <strong>application.properties</strong> file in <strong>src/main/resources</strong> folder.</p>
</li>
<li>
<p>Instead of hard-coding the database connection string, we want to configure it via the Application Settings of Azure Web App. So discard the changes you made in section 2.1. The code of application.properties should look like the following which is the same as what you pulled from GitHub first time. </p>
<pre><code class="language-java">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57InnoDBDialect
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
server.port=${PORT}
</code></pre>
</li>
<li>
<p>In the Terminal window, run command, <code>mvn clean package -DskipTests</code>, to package the code. </p>
</li>
<li>
<p>Find the package <strong>todowebjava-0.0.1-SNAPSHOT.jar</strong> in <strong>target</strong> folder. Right click and rename it to <strong>app.jar</strong>. </p>
</li>
<li>
<p>In VS Code, click <strong>Azure</strong> icon on the left navigation to open App Service explorer, and then click <strong>Sign in to Azure</strong>. </p>
</li>
<li>
<p>Click <strong>Copy &amp; Open</strong> in the popup window. See screenshot below. A browser window will be opened. </p>
<p><img src="appservice/images/ex2/azure-signin.png" alt="Azure Sign In" /></p>
</li>
<li>
<p>In the browser window, right click in the <strong>Code</strong> input, select <strong>Paste</strong> to paste the device code, and click <strong>Continue</strong> button. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex2/azure-device-code.png" alt="Device code" /></p>
</li>
<li>
<p>Sign in with the Azure account.</p>
</li>
<li>
<p>When you sign in successfully and see the following screen, close the browser window and go back to VS Code. </p>
<p><img src="appservice/images/ex2/azure-signin-complete.png" alt="Azure sign in complete" /></p>
</li>
<li>
<p>In <strong>Azure App Service</strong> explorer, expand the corresponding subscription and locate the Azure Web App. See screenshot below. </p>
<p><img src="appservice/images/ex2/azure-appsvc.png" alt="App service explorer" /></p>
</li>
<li>
<p>Right click <strong>Application Settings</strong> and click <strong>Add New Setting</strong>. Follow the instruction to add the following application settings. Alternatively you can also add these settings in Azure Portal. </p>
<p>|Name                       |Value    |
|---------------------------|---------|
|SPRING_DATASOURCE_URL      |jdbc:mysql://<em>[mysql server name]</em>.mysql.database.azure.com:3306/tododb?useSSL=true&amp;serverTimezone=UTC |
|SPRING_DATASOURCE_USERNAME |springuser@<em>[mysql server name]</em> |
|SPRING_DATASOURCE_PASSWORD |Spring1234                       |
|PORT                       |80                               |</p>
<p>Replace <em><strong>[mysql server name]</strong></em> with your MySQL server name. For details about how to find <em><strong>[mysql server name]</strong></em>, please refer to <a href="appservice/spring-boot-mysql.html#03---azure-database-for-mysql">Section 0.3</a>.</p>
</li>
<li>
<p>In VS Code, switch to workspace Explorer by clicking the <strong>Explorer</strong> button on the left navigation or press <code>Ctrl+Shift+E</code>. </p>
</li>
<li>
<p>Right click on <strong>app.jar</strong> and click <strong>Deploy to Web App</strong>. </p>
</li>
<li>
<p>Follow the instruction to choose the Azure subscription, and the existing Web App. In this lab, we <strong>don't</strong> use <em>Create New Web App</em> option. </p>
</li>
<li>
<p>In the popup dialog box, click <strong>Deploy</strong> button. The deployment process will be kicked off. You can open the Output window to see its progress. </p>
</li>
<li>
<p>When you see the following popup, the deployment completes successfully. Click <strong>Browse Website</strong> button to browse the website. </p>
<blockquote>
<p>[!NOTE]
You may have to restart the website in Azure Portal and wait for several minutes before you can see the home page of the website.</p>
</blockquote>
<p><img src="appservice/images/ex2/azure-deploy-success.png" alt="Deploy success" /></p>
</li>
<li>
<p>To verify if the site works properly, you can create a new task on the Todo page. Furthermore, you can use MySQL Workbench to connect to the MySQL server and query if the task you created is in the database.</p>
</li>
</ol>
<h2><a class="header" href="#exercise-3---implement-cicd-with-azure-devops" id="exercise-3---implement-cicd-with-azure-devops">Exercise 3 - Implement CI/CD with Azure DevOps</a></h2>
<p>In this exercise, we will implement CI/CD for our Spring Boot project with Azure DevOps pipelines. </p>
<h3><a class="header" href="#31---create-an-azure-devops-organization" id="31---create-an-azure-devops-organization">3.1 - Create an Azure DevOps organization</a></h3>
<p>Follow the steps below to create an Azure DevOps organization. We will use it to create CI/CD pipelines.</p>
<ol>
<li>
<p>Open browser and explore to <a href="https://dev.azure.com">https://dev.azure.com</a>. </p>
</li>
<li>
<p>Sign in with the provided Azure account. </p>
</li>
<li>
<p>After signing in successfully, click <strong>Start free</strong> button on the Azure DevOps page, and then follow the wizard to create the organization.</p>
</li>
<li>
<p>When the organization is ready, create an Azure DevOps project by providing a project name, for example, <em><strong>todowebjava</strong></em>, and clicking <strong>Create project</strong> button. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex3/create-proj.png" alt="Create project" /></p>
</li>
</ol>
<h3><a class="header" href="#32---push-the-code-repository-to-azure-devops-repos" id="32---push-the-code-repository-to-azure-devops-repos">3.2 - Push the code repository to Azure DevOps Repos</a></h3>
<p>Azure Pipelines support multiple source repositories, such as GitHub, Bitbucket etc. In our lab, we will use Azure Repos as the source repository. We need to push our source code from the local machine to Azure Repos. </p>
<ol>
<li>
<p>Update the URL of the <strong>origin</strong> branch of Git to Azure Repos' URL with the following command: </p>
<pre><code class="language-console">git remote set-url origin [Azure Repos URL]
</code></pre>
<p>To get the <em>[Azure Repos URL]</em>, on the Azure DevOps project page, click <strong>Repos &gt; Files</strong>. You will see <em><strong>push an existing repository from command line</strong></em> option. Copy the URL from there. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex3/origin-url.png" alt="Origin URL" /></p>
</li>
<li>
<p>Then push the repository to Azure Repos with command: <code>git push -u origin --all</code>. When prompt, sign in with the Azure account provided with the lab. </p>
</li>
<li>
<p>Once the repository is pushed successfully, you will be able to see the code in Azure DevOps. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex3/azure-repos-code.png" alt="Azure Repos" /></p>
</li>
</ol>
<h3><a class="header" href="#33---create-the-build-pipeline" id="33---create-the-build-pipeline">3.3 - Create the build pipeline</a></h3>
<p>When the source code is in Azure Repos, we can create a build pipeline to build the code. Azure Pipelines support two ways to create a build pipeline, YAML pipeline and Visual Designer. For the sake of time, we will use the Visual Designer in this lab. You can try YAML pipeline by yourself later. </p>
<ol>
<li>
<p>On Azure DevOps project page, click <strong>Pipelines &gt; Builds</strong>, and then click <strong>New pipeline</strong> button. </p>
</li>
<li>
<p>On the <strong>New pipeline</strong> page, click <strong>Use the visual designer</strong> link to switch to the visual designer. </p>
</li>
<li>
<p>Select <strong>Azure Repos Git</strong> as the source, and choose the corresponding project repository, then click <strong>Continue</strong>.</p>
</li>
<li>
<p>On the <strong>Choose a template</strong> page, choose <strong>Maven</strong> as the template. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex3/maven-template.png" alt="maven" /></p>
</li>
<li>
<p>When the build pipeline is created based on the Maven template, you don't even need to make any change. Azure Pipelines understand the Maven project and the default configurations are good enough for our lab. Go ahead to click <strong>Save &amp; queue</strong> to queue a new build.</p>
</li>
<li>
<p>When the build is kicked off, you can monitor the build status. When the build completes successfully, click <strong>Summary</strong> and <strong>Tests</strong> tabs to view the results. </p>
</li>
</ol>
<h3><a class="header" href="#34---create-the-release" id="34---create-the-release">3.4 - Create the release</a></h3>
<p>Follow the steps below to create the release pipeline. </p>
<ol>
<li>
<p>On Azure DevOps project page, click <strong>Pipeline &gt; Releases</strong>, and then click <strong>New pipeline</strong> button. </p>
</li>
<li>
<p>On the <strong>New release pipeline</strong> page, select <strong>Deploy a Java app to Azure App Service</strong> template. </p>
</li>
<li>
<p>Click <strong>Add an artifact</strong>, choose the build pipeline that you create in the previous exercise, choose <strong>Latest</strong> for <strong>Default version</strong>, and then click <strong>Add</strong>. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex3/release-artifact.png" alt="add artifact" /></p>
</li>
<li>
<p>Click <strong>1 job, 2 tasks</strong> link on <strong>Stage 1</strong> box. </p>
</li>
<li>
<p>We need to configure an Azure connection for the deployment. Click the <strong>Manage</strong> link besides <strong>Azure subscription</strong>. It will open the Azure connection settings page.</p>
</li>
<li>
<p>On the new page, click <strong>New service connection</strong> dropdown and click <strong>Azure Resource Manager</strong>. </p>
</li>
<li>
<p>On the popup window, input a <strong>Connection name</strong>, such as <em>Java Web App</em>, and choose the corresponding resource group from the dropdown, and then click <strong>OK</strong>. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex3/azure-connection.png" alt="Azure Connection" /></p>
</li>
<li>
<p>When the Azure connection is created successfully, go back to the <strong>New release pipeline</strong> page. Now you should be able to see the Azure connection you created in the <strong>Azure subscription</strong> dropdown list. If not, please click the refresh button besides the dropdown list and try again. Choose the Azure connection from the dropdown list. </p>
</li>
<li>
<p>For <strong>App type</strong>, choose <strong>Web App on Linux</strong>. And choose the corresponding Azure web app as <strong>App service name</strong>. See screenshot below as a reference. </p>
<p><img src="appservice/images/ex3/release-stage.png" alt="Release stage" /></p>
</li>
<li>
<p>As in our code we build a jar file rather than a war file, we will use <strong>Deploy Jar to Azure App Service</strong> task rather than <strong>Deploy War to Azure App Service</strong> task. So right click on <strong>Deploy War to Azure App Service</strong> and disable it, and right click on <strong>Deploy Jar to Azure App Service</strong> to enable it. </p>
</li>
<li>
<p>The most of the configurations for <strong>Deploy Jar to Azure App Service</strong> should have been generated. As in our code there is only one jar file, we can choose it specifically. Click the <strong>...</strong> button besides <strong>Package or folder</strong> option and locate the <strong>todowebjava-0.0.1-SNAPSHOT.jar</strong> file as shown in the screenshot below. </p>
<p><img src="appservice/images/ex3/locate-jar.png" alt="Locate Jar" /></p>
</li>
<li>
<p>With the above settings, we finish the configuration of the release pipeline. Click the <strong>Save</strong> button, and then <strong>Release &gt; Create a release</strong> to test the release pipeline. </p>
</li>
<li>
<p>On the <strong>Create a new release</strong> page, select <strong>Stage 1</strong> from the dropdown list and click <strong>Create</strong> button. </p>
</li>
<li>
<p>Click the new release created and then click <strong>Deploy</strong> button to kick start the deployment. You can click the stage box to open the console and monitor the progress of the deployment. </p>
</li>
<li>
<p>When the deployment completes successfully, explore the website in the browser. </p>
</li>
</ol>
<h3><a class="header" href="#35---clean-up-the-azure-devops-organization" id="35---clean-up-the-azure-devops-organization">3.5 - Clean up the Azure DevOps organization</a></h3>
<p>After you complete all exercises, please follow the steps below to clean up the Azure DevOps organization so that the Azure account of the lab can be reused. </p>
<ol>
<li>On Azure DevOps project page, click <strong>Azure DevOps</strong> logo at the upper left corner, and then click <strong>Organization settings</strong> at the lower left corner.</li>
<li>Click <strong>Overview</strong> under <strong>Organization Settings &gt; General</strong>. Scroll down and then click <strong>Delete</strong> button under <strong>Delete organization</strong>. </li>
<li>Copy and paste the organization name as shown in the popup window and click <strong>Delete</strong> button. </li>
</ol>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>You have completed all exercises in this lab. In this lab, we have tried to</p>
<ul>
<li>develop Java applications based on Spring Boot with Visual Studio Code.</li>
<li>deploy and run Java applications on Azure App Service on Linux. </li>
<li>implement CI/CD for Spring Boot project with Azure DevOps.</li>
</ul>
<p>Hope you've got the hands-on experience and better understanding regarding how Java and Azure could work together. </p>
<h3><a class="header" href="#additional-resources" id="additional-resources">Additional resources</a></h3>
<p>If you want to learn more about Java on Azure, the following resources could be used as starting points.</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/java/azure/?view=azure-java-stable">Azure for Java developers</a></li>
<li><a href="https://code.visualstudio.com/docs/languages/java">Java in Visual Studio Code</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/devops/java/?view=vsts">Working with Azure DevOps and Java</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
